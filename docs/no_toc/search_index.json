[["index.html", "Using AI for Software About this Course Available course formats Suggested Activity Context Lesson Breakdown", " Using AI for Software April, 2023 About this Course This course on AI for software development explores the use of AI large language models such as ChatGPT, Bard, and others and their potential benefits and challenges. Through examples and hands-on activities, students will develop an understanding of the ways in which AI can speed up software development tasks and free up time for more creative and strategic work. By the end of the course, students will be equipped to navigate the rapidly changing landscape of software development and use AI chatbots in a way that maximizes benefits and efficiency while limiting harm as much as possible. Available course formats This course is available in multiple formats which allows you to take it in the way that best suits your needs. The material for this course can be viewed without login requirement on this Bookdown website. This format might be most appropriate for you if you rely on screen-reader technology. Our courses are open source, you can find the source material for this course on GitHub. Suggested Activity Context Course Audience Professionals looking to improve efficiency Students hoping to learn more about programming Anyone curious about how AI can be harnessed for technology Course Prerequisites Some previous exposure to programming recommended. Assessment Type Hands-on activities following each lesson. Lesson Breakdown Activity Duration Introduction 10 minutes Writing and Debugging Code 10 minutes Refactoring Code 35 minutes Refactoring Exercise 15 minutes Annotating Code 25 minutes Understanding Code 25 minutes Total 2 hours &amp; 10 minutes "],["introduction.html", "Chapter 1 Introduction 1.1 AI provides new opportunities 1.2 AI code of ethics 1.3 The AI chatbots 1.4 About this book", " Chapter 1 Introduction The increasing availability of AI chatbots is creating a new landscape in software development. It is important to be aware of the potential benefits and challenges of this technology, so that we can use it in a way that benefits everyone and limits harm as much as possible. On the one hand, AI chatbots have the potential to replace or significantly reduce the workload of programmers. This could lead to job losses in the software development industry. Additionally, there are significant ethical and privacy concerns regarding the use of training data sets to teach these AI systems. For example, if a chatbot is trained on a dataset of biased or discriminatory data, it could perpetuate those biases in its interactions with users. On the other hand, AI chatbots also have the potential to create new jobs and opportunities in the software development industry. For example, chatbot developers will be needed to create and maintain these AI systems. Additionally, AI chatbots could be used to automate tasks that are currently done by humans, freeing up programmers to focus on more creative and strategic work. Ultimately, while the future of software development is unclear, there is much to be optimistic about in this brave new world. The advancements in AI and chatbot technology present an opportunity for programmers to work alongside algorithms to create innovative solutions that were previously unimaginable. As with any technological revolution, there will be challenges, but it is up to us to work together to ensure that we use these tools ethically and responsibly, and to create a future that benefits everyone. 1.1 AI provides new opportunities We do not believe that AI chatbots will replace software developers. While AI can be powerful and useful, it is only as good as the training data behind it and the human using it. Therefore, for the time being and the foreseeable future, humans will remain at the forefront of programming innovation, with AI providing valuable support. As new code is often built on top of existing code written by humans, it is unlikely that AI will fully replace the need for human programmers. However, we do think that the roles of programmers in software development are changing, and some of the skills required to work in this new environment are slightly different from those needed before. In addition to proficiency in programming syntax, programmers may need to develop a more refined ability to construct queries that enable AI bots to create the desired workflows. Other critical skills such as debugging, troubleshooting, and documentation will continue to be valuable, and can be enhanced through the use of AI. Furthermore, AI creates new opportunities and niches for tasks that were previously difficult, time-consuming, or impossible. This is an exciting time for those working in programming, with great potential to explore new and innovative solutions. As AI technology continues to advance, its role in programming will only become more significant, and it is up to developers to adapt and learn how to use these new tools effectively. We asked OpenAI’s ChatGPT whether AI chatbots would replace human software developers and programmers, and this was the response: “No, ChatGPT is not replacing human software developers and programmers. While ChatGPT is capable of generating code, it is not a substitute for the skills and expertise of human programmers. Software development is a complex process that requires a deep understanding of programming languages, algorithms, and software design principles. Human programmers have the ability to not only write code, but also to understand the nuances of different programming languages and frameworks, debug code, and optimize performance. Furthermore, programming is not just about writing code - it also involves understanding and translating business requirements into technical solutions, collaborating with other team members, and maintaining code over time. While ChatGPT can be used to automate certain aspects of software development, it cannot replace the creativity, problem-solving skills, and domain expertise of human software developers and programmers.” 1.2 AI code of ethics Our first duty as programmers is to avoid causing harm to people and the world. This includes avoiding both intentional and inadvertent harm. Intentional harm is harm that is caused by a programmer’s deliberate actions. For example, a programmer might create a virus that is designed to harm computers. Inadvertent harm is harm that is caused by a programmer’s negligence or lack of foresight. For example, a programmer might create a program that is buggy and causes data loss. We must always be aware of the potential for harm and deliberately take steps to mitigate it. This includes things like: Be aware of the potential for bias. AI systems are trained on data, and that data can reflect the biases of the people who collected it. Programmers should be aware of the potential for bias in their data and take steps to mitigate it. Be transparent about your work. Share information about your code, data, and algorithms. This will help others to understand how your work works and to identify any potential problems. Be accountable for your work. Take responsibility for the consequences of your code. Be willing to make changes if necessary. Participate in discussions about AI ethics. There are many online and in-person communities where you can discuss the ethical implications of AI with other people. Advocate for ethical AI. Speak up when you see AI being used in a way that you believe is unethical. Support organizations that are working to promote ethical AI. 1.3 The AI chatbots Although humans have been interacting with AI chatbots for years, the popularity of OpenAI’s ChatGPT and DALL-E programs has sparked a recent surge of interest in them. We will use a variety of chatbots as examples throughout this course. Some AIs will be better suited for your particular tasks, and it is too early to judge which of the technologies will end up dominating the industry. We encourage you to test multiple AI platforms to find the ones that best fit your needs, and the use of a particular AI in each chapter should not be taken as an endorsement by us. Bard is Google’s large language model, also known as a conversational AI or chatbot trained to be informative and comprehensive. It is trained on a massive amount of text data and is able to communicate and generate human-like text in response to a wide range of prompts and questions. You will need to join the waiting list before getting access, although in our experience the wait time is short. ChatGPT is OpenAI’s large language model based on the GPT (Generative Pre-trained Transformer) architecture. It is designed to understand and generate human-like responses to text-based conversations. You will need to create an account before using it. CodePilot by Github is a language bot that interfaces with your editor. In addition to providing coding suggestions and speeding up testing, this bot does not offer suggestions that match public code. It’s a subscription model with both individual and business tiers. CodeWhisperer is the Amazon Web Services chatbot. It can be installed in your integrated development environment (IDE) using the latest AWS Toolkit plugin. The individual tier for CodeWhisperer is free. although you will need to create an AWS account and add a payment method. Phind is a AI-powered search engine designed specifically for developers asking technical questions. In addition to answering your coding question, it will provide links to the internet sources used to find the answer. Poe is Quora’s platform that gives you access to multiple AI chatbots, including Sage, based on OpenAI’s GPT-3.5 architecture; Claude, an AI natural language bot created by Anthropic; and Ehang’s Dragonfly AI platform, which was created to interface with their Dragonfly drone. Poe also gives you access to ChatGPT. 1.4 About this book We used AI bots (including ChatGPT, Bard, Sage, and Claude) to develop and write much of this course. We firmly believe this new technology can be used in ethical ways and we put into practice all the rules and suggestions offered over the following modules. It is up to the human behind it to make sure that AI is used properly and transparently. Throughout this course, you will see two types of specially-colored boxes. One box highlights potential ethical issues with an AI usage. In this box, you’ll find reminders of the ethical considerations you should be particularly aware of while using AI to do certain tasks. The other box highlights our queries to AI chatbots. The question we posed to the AI chatbot is written in these boxes to make it easier for you to find. Wherever possible, we use screenshots of the actual answers we got from the AI chatbots in response to our questions. Occasionally when we have asked for the AI to write or fix code, we have formatted the answer in such a way that makes it easier to use. When you see this format, you will know it indicates an AI response Code in these boxes was written by AI. Finally, we want to reiterate a point we made above: the use of a particular AI should not be taken as an endorsement by us. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-25 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## curl 4.3 2019-12-02 [1] RSPM (R 4.0.3) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## highr 0.8 2019-03-20 [1] RSPM (R 4.0.3) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## httr 1.4.2 2020-07-20 [1] RSPM (R 4.0.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["writing-and-debugging-code.html", "Chapter 2 Writing and Debugging Code 2.1 Using AI to write code 2.2 The Basics 2.3 Selecting a Language: 2.4 Prompt Generation:", " Chapter 2 Writing and Debugging Code In today’s digitally-driven world, coding has become an essential skill. It is used to create websites, mobile applications, and sophisticated software systems. Contrary to popular belief, coding is not only for those who possess an innate talent for programming. With the right resources and a willingness to learn, anyone can become proficient in coding. Practice is crucial to mastering the art of coding, and those who are willing to commit themselves to the learning process can achieve great results. Writing code can also be a rewarding and fulfilling hobby, too. Creating your own software, building a website, or automating a task can be immensely satisfying, and can provide a sense of accomplishment and pride. Moreover, writing code can be a form of creative expression. Just as musicians use notes to compose music and artists use paint to create visual art, programmers use code to create digital experiences. From building websites to creating video games, code can be used to bring ideas to life in exciting and innovative ways. Ultimately, the ability to write code is a valuable asset in today’s world, with increasing demand for skilled programmers in a wide range of industries. Whether as a career or hobby, coding can be both personally and professionally rewarding. The accessibility and versatility of coding make it an excellent skill for anyone to learn, regardless of their background or previous experience. 2.1 Using AI to write code AI-powered programming tools and technologies are revolutionizing the way we approach software development. AI can be used to generate code snippets, which can save developers significant amounts of time and increase productivity. This is because AI can analyze existing code and learn from it to generate code that is similar to what a human programmer might write, but in a fraction of the time. Additionally, AI makes it possible for people to write code in languages with which they are only slightly familiar. AI can also provide guidance and suggestions for human programmers. For example, an AI-powered code editor might suggest more efficient algorithms or highlight potential errors in real-time. This can help reduce the number of bugs and errors in code, leading to better performance and a more efficient development process. One of the most promising aspects of AI-powered programming is its potential to make programming more accessible to a wider range of people. With AI-generated code and automated programming tools, individuals who are not experienced developers can still create software solutions. This has the potential to democratize programming and lead to new innovations from a wider range of people. The rise of AI technologies is transforming software development and changing the skills required for writing code. Rather than simply memorizing syntax, developers need to focus on developing their creativity, intuition, and problem-solving skills. Additionally, programmers must also hone their abilities in architecture design and project management, as these skills are becoming increasingly important in the modern software development landscape. The use of artificial intelligence (AI) in coding has raised a number of ethical concerns. One of the biggest concerns is the potential for AI to create biased or harmful code. AI systems are trained on data created by humans. If this data used to train the system is biased, the resulting code could also be biased. This could lead to discrimination against certain groups of people, such as those with certain ethnic or cultural backgrounds, genders, or ages. Another major concern is the use of AI to generate malicious code. For instance, AI could be used to create code that spreads malware or hacks into computer systems. This could cause severe damage to individuals and organizations, including data breaches and financial losses. When AI systems are trained on data, they may also learn and incorporate code from that data. This means that AI-generated code could potentially infringe on the copyright of the original author of the code. For example, if an AI system is trained on a GitHub repository that contains code written by a human programmer, the AI system could generate code that is identical to or similar to the code in the GitHub repository. If the AI system then uses this code without permission from the original author, this could constitute copyright infringement. In general, we want programmers to feel comfortable sharing their code openly without fear they won’t be credited. Similarly, AI systems could potentially infringe on intellectual property rights by using code that is protected by trademarks or patents. For example, if an AI system is trained on a training manual that contains code that is protected by a trademark, the AI system could generate code that is identical to or similar to the code in the training manual. If the AI system then uses this code without permission from the trademark owner, this could constitute trademark infringement. There is also a risk that AI-generated code could be unintelligible to humans. This could make it difficult to understand how the code works and could make it hard to identify and fix any issues that may arise. This could result in negative consequences, such as system crashes or security breaches, that could have been avoided if the code had been written by a human programmer. It is essential to address these ethical concerns and ensure that the use of AI in coding is done in a responsible and transparent manner. This could be done through ensuring the quality of the data used to train AI systems, promoting transparency in AI-generated code, and implementing safeguards against the creation of harmful or biased code. By doing so, we can harness the potential of AI to improve and transform the way we write and optimize code while maintaining ethical standards. As a programmer using AI, it is up to you to be responsible for what you create. You must rigorously test any code you write and also take care that you are only using code that you’re authorized to use. This means asking the AI chatbot where code snippets are from and tracking down those citations and authorizations yourself (instead of just trusting the AI that everything is okay). Here are some additional tips for using AI responsibly in coding: Be aware of the potential biases in the data that is used to train AI systems. Make sure that you understand the code that you are using, even if it was generated by AI. Be careful about what code you share publicly, as it could be used for malicious purposes. Obtain permission from the copyright holders of any code that you use to train the AI system. Only use code that is in the public domain or that has been licensed for use by the AI system’s owner. Cite any GitHub repositories or training manuals you might use in your code 2.2 The Basics Using AI to write code is as much of an art as writing your own code. You can jump right in and ask your AI chatbot to write the code, but you’re unlikely to be successful and incredibly likely to get frustrated. Before you start interacting with the AI, you need to plan out what you want to do. Following a few rules and suggestions will make your experience much more enjoyable and productive. The first rule about using AI is to remember that it cannot read your mind. You need to tell it what you’re thinking, and it may take several rounds of question-and-answer before you get something you can work with. Be clear about your goals. What do you want the AI to do? Be as specific as possible. Start with a simple task. Don’t try to do too much too soon. Start with a simple task and then gradually work your way up to more complex tasks. You wouldn’t write a complete program all at once, and you shouldn’t have AI do it, either. Provide enough data. The more data (and detail) you can give the AI, the better it will be able to learn and perform the task you want it to do. Be patient. Querying an AI can take time. Don’t expect it to be perfect right away. The second rule about using AI is to test everything. You are responsible for the code that AI generates, even if you didn’t write it yourself. AI can be biased, just like humans, and this could lead to sub optimal development. There is a concern that AI may focus development on areas that optimize certain metrics but not overall quality, effectiveness, or user needs. Human judgment is still needed to ensure that AI is used in a responsible and ethical way. Test your results. Make sure the AI is actually doing what you want it to do. AI systems are trained on data, and if the data is not representative of the real world, the AI system may not be able to generate code that works correctly. It is important to test the code to make sure that it is working as intended and that it is producing the desired results. Inadequate testing could lead to low quality, buggy code. Since AI generated code would be highly automated, it requires strong testing procedures and safety oversight to ensure it meets standards before deployment. Make sure your code is secure. AI systems can be used to generate code that is vulnerable to attack, and it is important to test the code to make sure that it is secure. This can help to prevent security breaches from occurring. Use a variety of AI models. There are many different AI models available. Experiment with different models to see which one works best for your task. Get feedback from others. Ask other people to review your code and give you feedback. This can help you identify and fix any problems with your code. 2.3 Selecting a Language: Selecting a language in which to develop software is an important first step. You might choose a language based on: Your preexisting knowledge or experience with the language A specific use case where the language is commonly used The language(s) your colleagues or coworkers use Here are commonly used languages and their typical use cases. Python Known for its readability, simple syntax, and comprehensive add-on modules. It is often recommended as a beginner-friendly language. Python is used for scientific computing, data analysis, machine learning, and web development. Many Data Scientist roles rely on Python. Ruby Similar to Python, Ruby is also known for its readability and user-friendly syntax. It is typically used for web development, building dynamic websites, and creating web applications. JavaScript A popular language for web development, known for its versatility and ease of use. Many of the interactive features of websites rely on JavaScript. Java Java is widely used for enterprise applications, android mobile apps, and web apps. PHP PHP is easy to learn but can become complex as the application grows. It is typically used for building dynamic web pages, web applications, and content management systems. R Used for statistical computing, data analysis, and data visualization, R is a popular choice for researchers and data scientists. Some beginners find its syntax complex, especially due to differences in the two major dialects: “base” R versus the “tidyverse”. Kotlin Kotlin is a relatively new language that is designed to be more concise and expressive than Java. However, its advanced features and concepts may be challenging for beginners. It is used for developing Android mobile apps, web development, and server-side development. Swift Used for iOS and macOS app development, Swift is known for its strict syntax and steep learning curve. C# Often used for Windows desktop applications, web applications, and video games, C# can be challenging due to its more complex syntax and strict type system. C++ A powerful language often used for developing high-performance applications and operating systems, C++ can be challenging to learn due to its complexity and the need to manage memory manually. You can find a description of other languages you might encounter here. 2.4 Prompt Generation: Create a set of prompts that will be used to guide participants in writing code in the selected language. These prompts should be specific enough to provide guidance, but open-ended enough to allow participants to exercise their creativity and problem-solving skills. For the example(s), walk participants through the process of interacting with ChatGPT and provide tips on how to refine their queries to get the best results. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-25 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["refactoring-code.html", "Chapter 3 Refactoring Code 3.1 AI in Code Refactoring 3.2 Example One: Correcting Syntax 3.3 Example Two: Styling and Convention 3.4 Example Three: Staying DRY 3.5 Example Four: Keeping Code Alive 3.6 Example Five: Making Code Readable 3.7 Example Six: Keep it Brief 3.8 Code optimization 3.9 Challenges and Limitations 3.10 Hands-On Exercise", " Chapter 3 Refactoring Code Code refactoring is the process of improving the quality of underlying code without changing its functionality. In other words, it’s a way of cleaning up and optimizing code so that it’s easier to maintain and more efficient. This often involves making small changes to the code, such as renaming variables or functions, reorganizing code blocks, or simplifying complex expressions. Refactoring is an essential practice in software development and helps to ensure that the codebase remains manageable and adaptable as requirements and business needs change over time. Code refactoring helps to reduce technical debt, which is the accumulation of development work that needs to be done in the future as a result of taking shortcuts or using less than optimal solutions. Refactoring can help to identify potential issues and bugs before they cause problems, resulting in more stable software. Finally, refactoring code to be more readable and less verbose can create fewer headaches for you in the future. To understand why code refactoring is important, imagine trying to cook in a disorganized and cluttered kitchen. You might be a fantastic cook, but you are spending more time searching for utensils and ingredients, and the quality of the meal could suffer as a result. Similarly, code that is disorganized and cluttered can be difficult to work with and can result in lower-quality software. Refactoring is like cleaning and organizing the kitchen - it makes the process of cooking (or coding) smoother and more efficient. 3.1 AI in Code Refactoring Code refactoring has historically been done manually by developers. This involves reviewing code and identifying areas that could be improved or optimized, and then making changes to the codebase accordingly. Though important, this is process is time-consuming and labor-intensive, as it requires developers to carefully review every line of code to identify potential issues or areas for improvement. Additionally, manual code refactoring is error-prone, as developers can accidentally introduce bugs or errors into the codebase while making changes. However, AI has significant potential to help with code refactoring. AI can use machine learning algorithms to analyze large amounts of code and identify patterns or areas that could be improved. For example, they can identify sections of code that are redundant, overly complex, or difficult to maintain, and suggest changes that could be made to improve the codebase. Machine learning algorithms can also help to identify potential bugs or security issues in the codebase, which can help to improve the overall quality and stability of the software. AI refactoring is also faster and more accurate than manual refactoring. This is particularly useful for large-scale software projects with massive codebases, where manual code review and refactoring can be an enormous task. In the next sections, we’ll take a look at some examples of using AI to refactor code. 3.2 Example One: Correcting Syntax Programming languages operate using their established set of rules. For example, Python uses indentation to define code blocks. However, when you shift between development environments, indentation and line breaks can sometimes be affected, causing major headaches! Let’s say we run the following code: def calculate_sum(a,b): result = a + b return result def calculate_product(a,b):result = a * b return result def main(): a=5 b=6 sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) product_result = calculate_product(a,b) print(&quot;Product:&quot;, product_result) if __name__ == &#39;__main__&#39;: main() ## unexpected indent (&lt;string&gt;, line 3) We get the error above because our indentation is off. Let’s ask ChatGPT to clean things up. “Can you assist me with correcting the formatting and indentation issues in my Python code?” Of course! Here is the code after correcting the formatting and indentation: def calculate_sum(a, b): result = a + b return result def calculate_product(a, b): result = a * b return result def main(): a = 5 b = 6 sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) product_result = calculate_product(a, b) print(&quot;Product:&quot;, product_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 ## Product: 30 Much better! This can be quite handy when you can’t immediately see what is wrong with the formatting or if you are working with a large codebase. 3.3 Example Two: Styling and Convention Sometimes programming languages have more flexible rules where there are multiple ways to take the same or almost the same action. For example, in the R programming language, there are several ways to perform variable assignment. However, is is generally accepted among R programmers that the &lt;- operator should be used. Single and double quotes can be used for character types interchangeably, but it’s generally a good idea to stick with one or the other. 3.3.1 Commonly Accepted Convention Let’s say we have the following code: a &lt;- &quot;apple&quot; b = &#39;banana&#39; &quot;carrot&quot; -&gt; c c(a, b, c) ## [1] &quot;apple&quot; &quot;banana&quot; &quot;carrot&quot; This code does not produce any errors, but it doesn’t follow typical R convention. Let’s ask ChatGPT to clean things up. “Can you help me reformat my R code to follow accepted style conventions?” Sure, here’s the cleaned-up R code: a &lt;- &quot;apple&quot; b &lt;- &quot;banana&quot; c &lt;- &quot;carrot&quot; Much better! This code will now look more familiar to other R programmers. 3.3.2 Visual Styling Some languages are flexible about line breaks, indentation, and spacing among code blocks. If you’re rapidly developing, things can get messy pretty quickly. Many development environments, for example RStudio and PyCharm, have the ability to format your code for you without changing any of the code itself. However, you can also get AI to do this according to your own preferences. d &lt;- c(rep(a,5),rep(b,5),rep(c,5),paste(a,b,c),paste(c,b,a)) This code is pretty hard to read. Let’s see if AI can do better. “Can you space out this R code to make it more readable?” Sure! Here’s the same code with added spacing for improved readability: d &lt;- c(rep(a, 5), rep(b, 5), rep(c, 5), paste(a, b, c), paste(c, b, a)) Better! It’s easier to interpret because only one action is being taken on each step. By spacing out the code and breaking it into multiple lines, it becomes easier for the human eye to scan for structure, logic, errors, and/or inconsistencies. 3.4 Example Three: Staying DRY The DRY (Don’t Repeat Yourself) programming tenet is essential to good software. By avoiding repetition in code, we can reduce the amount of duplicate code we need to write and maintain. If we need to change the functionality of a certain piece of code, we have to make the same change in multiple places, which can be time-consuming and error-prone. Let’s take the following Python code: def print_greetings(): print(&quot;Hello, Alice!&quot;) print(&quot;Hello, Bob!&quot;) print(&quot;Hello, Carol!&quot;) print(&quot;Hello, David!&quot;) print(&quot;Hello, Eve!&quot;) print_greetings() ## Hello, Alice! ## Hello, Bob! ## Hello, Carol! ## Hello, David! ## Hello, Eve! Notice how repetitive this code is? print() and the string \"Hello, \" appear five times. We can improve this! “Could you please refactor my Python code to make it more DRY?” Sure, here’s a refactored version of your code: def print_greeting(name): print(f&quot;Hello, {name}!&quot;) def print_greetings(): names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;David&quot;, &quot;Eve&quot;] for name in names: print_greeting(name) print_greetings() ## Hello, Alice! ## Hello, Bob! ## Hello, Carol! ## Hello, David! ## Hello, Eve! Now let’s imagine your software lead has asked us to change the greeting to Spanish. Notice how we only have to change the second line of code: def print_greeting(name): print(f&quot;¡Hola, {name}!&quot;) def print_greetings(): names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;David&quot;, &quot;Eve&quot;] for name in names: print_greeting(name) print_greetings() ## ¡Hola, Alice! ## ¡Hola, Bob! ## ¡Hola, Carol! ## ¡Hola, David! ## ¡Hola, Eve! Much easier. 3.5 Example Four: Keeping Code Alive During software development, code is often changing rapidly. It’s common to end up with functions or variables you don’t need anymore. It’s best practice to remove “dead” code from your codebase: it’s distracting and can make maintenance more challenging. Programmers should resist the urge to hang on to unused code in the expectation that they might need it one day. Version control, such as provided by git and GitHub, let you keep a record of old code without cluttering your final version. Let’s take a look at some Python code with some dead code: def default_values(): a = 5 b = 6 return a, b def calculate_sum(a, b): result = a + b return result def calculate_product(x, y): return x * y def simulate_data(): a, b = default_values() dat = calculate_sum(a, b) + calculate_sum(a, b) return dat def main(): a = 5 b = 6 a, b = default_values() sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 Some of these functions aren’t used in the final step, typically defined in python as the main() function. Let’s ask AI to remove them. “I need help with eliminating unused functions in my Python script.” Sure! Here’s a refactored version: def default_values(): a = 5 b = 6 return a, b def calculate_sum(a, b): result = a + b return result def main(): a = 5 b = 6 a, b = default_values() sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 Great! Now our code is much more manageable. This code only includes the necessary functions needed to run the main() function. We can go a step further! “Can you help me refactor my python code to make it more concise?” Certainly! Here’s a more concise version of your code: def calculate_sum(a=5, b=6): return a + b def main(): sum_result = calculate_sum() print(&quot;Sum:&quot;, sum_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 In this version, the calculate_sum function is simplified to take default arguments for a and b. This means the default_values function is no longer necessary. The a and b variables are also removed from main, as they are no longer needed. Much better and easier to look at overall. 3.6 Example Five: Making Code Readable Usually, our first goal as programmers is to get the response we need from the code. Readability might be the last thing on our minds. Luckily, AI can help with this. Let’s imagine we whipped up this code pretty quickly. It is tough to read, and it could definitely be improved. for(term in c(&quot;good&quot;,&quot;bad&quot;,&quot;ugly&quot;)){ print(c(rep(term,3),paste(&quot;really&quot;,stringr::str_to_upper(term)))) } ## [1] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;really GOOD&quot; ## [1] &quot;bad&quot; &quot;bad&quot; &quot;bad&quot; &quot;really BAD&quot; ## [1] &quot;ugly&quot; &quot;ugly&quot; &quot;ugly&quot; &quot;really UGLY&quot; Let’s see if AI can do better. “Can you help me clean up this R code so it is more readable?” Sure! Here’s a more readable version of the code: library(stringr) for(term in c(&quot;good&quot;, &quot;bad&quot;, &quot;ugly&quot;)) { print(c(rep(term, 3), paste(&quot;really&quot;, str_to_upper(term)))) } ## [1] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;really GOOD&quot; ## [1] &quot;bad&quot; &quot;bad&quot; &quot;bad&quot; &quot;really BAD&quot; ## [1] &quot;ugly&quot; &quot;ugly&quot; &quot;ugly&quot; &quot;really UGLY&quot; I added whitespace around operators and after commas for better readability. I also loaded the stringr package explicitly using library() to make the code more self-contained. This is a good start, but not much has changed. Let’s try again. On ChatGPT, we can click “Regenerate Response”. Here’s a cleaned-up version of the R code that is more readable: library(stringr) terms &lt;- c(&quot;good&quot;, &quot;bad&quot;, &quot;ugly&quot;) for (term in terms) { rep_term &lt;- rep(term, 3) upper_term &lt;- str_to_upper(term) really_upper_term &lt;- paste(&quot;really&quot;, upper_term) result &lt;- c(rep_term, really_upper_term) print(result) } ## [1] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;really GOOD&quot; ## [1] &quot;bad&quot; &quot;bad&quot; &quot;bad&quot; &quot;really BAD&quot; ## [1] &quot;ugly&quot; &quot;ugly&quot; &quot;ugly&quot; &quot;really UGLY&quot; I’ve stored the repeated term and the uppercased term in separate variables to make the code more readable. I’ve also separated the construction of the “really” phrase from the uppercased term to make it clearer what’s happening. Finally, I’ve used whitespace and indentation to make the structure of the code more apparent. Better! While the code takes up a greater number of lines, it’s easier to interpret because only one action is being taken on each step. 3.7 Example Six: Keep it Brief As we learned above, following the DRY principle and removing dead code can make your code easier to interpret, maintain, and debug. However, sometimes the issue is the functions themselves. No one has perfect knowledge of everything in their programming language. AI can help us determine if there are any more efficient sets of functions that do the same thing. Here is some code that plays with the “CO2” dataset in R: library(datasets) for (type in unique(CO2$Type)) { dat_subset &lt;- CO2[CO2$Type == type, ] for (plant in unique(dat_subset$Plant)) { dat_subset_2 &lt;- dat_subset[dat_subset$Plant == plant, ] print(paste(dat_subset_2$Plant[1], round(mean(dat_subset_2$uptake), 1))) } } ## [1] &quot;Qn1 33.2&quot; ## [1] &quot;Qn2 35.2&quot; ## [1] &quot;Qn3 37.6&quot; ## [1] &quot;Qc1 30&quot; ## [1] &quot;Qc2 32.7&quot; ## [1] &quot;Qc3 32.6&quot; ## [1] &quot;Mn1 26.4&quot; ## [1] &quot;Mn2 27.3&quot; ## [1] &quot;Mn3 24.1&quot; ## [1] &quot;Mc1 18&quot; ## [1] &quot;Mc2 12.1&quot; ## [1] &quot;Mc3 17.3&quot; Let’s see if AI has any ideas for making it more concise. “Can you make this code more concise?” Here’s a more concise version using dplyr package in R: library(dplyr) CO2 %&gt;% group_by(Type, Plant) %&gt;% summarize(mean_uptake = mean(uptake)) ## # A tibble: 12 × 3 ## # Groups: Type [2] ## Type Plant mean_uptake ## &lt;fct&gt; &lt;ord&gt; &lt;dbl&gt; ## 1 Quebec Qn1 33.2 ## 2 Quebec Qn2 35.2 ## 3 Quebec Qn3 37.6 ## 4 Quebec Qc1 30.0 ## 5 Quebec Qc3 32.6 ## 6 Quebec Qc2 32.7 ## 7 Mississippi Mn3 24.1 ## 8 Mississippi Mn2 27.3 ## 9 Mississippi Mn1 26.4 ## 10 Mississippi Mc2 12.1 ## 11 Mississippi Mc3 17.3 ## 12 Mississippi Mc1 18 This code groups the CO2 dataset by Type and Plant, calculates the mean uptake for each group using summarize, and then prints the resulting data frame. The code is shorter and more concise because it uses the dplyr package, which has built-in functions for data manipulation and summarization. Refactoring the code to be more concise using dplyr makes it easier to read and understand the steps involved in the data manipulation. It also reduces the number of nested loops and intermediate variables, making the code more efficient and reducing the chance of errors. Ultimately, it is your job as a programmer to use your best judgment on the fine balance between brevity and readability, as the best solution is not always this obvious. Remember that you can regenerate the AI’s response if you want more options. 3.8 Code optimization Sometimes time and efficiency is of the essence. Loops can be slow and time consuming in many languages. Take for example the following R code that calculates the cross product between two vectors x and y using nested for loops: set.seed(123) n &lt;- 10000 x &lt;- rnorm(n) y &lt;- rnorm(n) z &lt;- numeric(n) # Start timer start_time &lt;- proc.time() for(i in 1:n) { for(j in 1:n) { z[i] &lt;- z[i] + x[i]*y[j] } } # End timer proc.time() - start_time ## user system elapsed ## 270.952 0.140 271.106 “What is a faster, more optimized way of running the following R code?” set.seed(123) n &lt;- 10000 x &lt;- rnorm(n) y &lt;- rnorm(n) # Start timer start_time &lt;- proc.time() z &lt;- outer(x, y, &quot;*&quot;) z &lt;- rowSums(z) # End timer proc.time() - start_time ## user system elapsed ## 0.716 0.373 0.989 The outer() function performs the same calculation as the nested loop in the original code, but more efficiently. It returns a matrix of all possible combinations of x and y values, with each element of the matrix being the product of the corresponding x and y values. The rowSums() function is then used to sum the elements of each row of the matrix, which is equivalent to summing the products of x and y for each index i in the original loop. This method avoids the need for the nested loop, resulting in a faster and more efficient computation. So much faster! We can look at another option by regenerating the response: set.seed(123) n &lt;- 10000 x &lt;- rnorm(n) y &lt;- rnorm(n) z &lt;- numeric(n) # Start timer start_time &lt;- proc.time() z &lt;- x %*% t(y) # End timer proc.time() - start_time ## user system elapsed ## 0.427 0.324 0.485 One optimized way to perform the same calculation is by using the %*% operator to perform matrix multiplication. This can be done by converting x and y to matrices and transposing one of them so that their dimensions align for matrix multiplication. This code should be much faster than the original implementation because it takes advantage of highly optimized matrix multiplication algorithms in R. While this second suggestion is faster, you will need to consider what aspects of the codebase are most important in each instance. For example, this code runs more quickly, but the %*% operator might be unfamiliar to some R programmers. In cases where efficiency is less important, or the data are not large, you might consider maximizing readability. 3.9 Challenges and Limitations Like humans, AI can make mistakes. Be sure to keep the following in mind as you use AI to refactor your code. 3.9.1 Complexity Refactoring is often a complex process that requires deep understanding of the code and its context. AI may not always be able to fully understand the complexity of the code and may struggle to identify the best refactoring strategy. Use a modular approach whenever possible. 3.9.2 Limited Data AI models require large amounts of data to learn from, but in the case of code refactoring, there is often limited data available. This can make it difficult for AI models to generalize to new code bases and situations, especially if you are using a more niche programming language. 3.9.3 Quality Control Automated refactoring tools that use AI may not always produce code that is of the same quality as code produced by human developers. It can be difficult to always ensure that the refactored code is maintainable, efficient, and free of bugs. You need to use your best judgment when copying and pasting AI-produced code into your codebase. You should always include unit tests in your code. Tests can help you catch bugs, including those introduced accidentally by AI. Because AI models are created by humans, they can be biased. This means they may not always identify your preferred refactorings or may prioritize certain types of refactorings over others. In some cases, this can lead to suboptimal code quality and may create technical debt over time. 3.9.4 Security When using AI to refactor code, the code itself is often sent to an external service or platform for analysis and transformation. This can raise concerns about the security of the code, especially if it contains sensitive information such as trade secrets, proprietary algorithms, or personal data. If your code is sensitive, it’s important to carefully vet any third-party AI tools or services used in the refactoring process. 3.10 Hands-On Exercise Now it’s your turn to try. 3.10.1 The Code Let’s say you are dusting off some code from your past (no judgment here). You were investigating tweets about Mr. Trash Wheel, a beloved Baltimore-based contraption that filters trash out of the waterways. Note: This code is just an example and was written strictly for educational purposes. import tweepy import pandas # Enter your API keys and access tokens here consumer_key = &#39;your_consumer_key&#39; consumer_secret = &quot;your_consumer_secret&quot; access_token = &#39;your_access_token&#39; access_token_secret = &#39;your_access_token_secret&#39; # Authenticate with Twitter API auth = tweepy.OAuthHandler(consumer_key, consumer_secret) auth.set_access_token(access_token, access_token_secret) # Search for tweets containing the search term tweets = tweepy.Cursor(tweepy.API(auth).search_tweets, q=&quot;Mr. Trash Wheel&quot;, tweet_mode=&#39;extended&#39;).items(100) # Create empty list to store tweet data date_data = [] location_data = [] text_data = [] def get_tweet_length(tweet): # Return the length of the tweet text return len(tweet.full_text) # Loop through each tweet and extract desired data for tweet in tweets: date_info = { &#39;date&#39;: tweet.created_at } date_data.append(date_info) # Search for tweets containing the search term tweets = tweepy.Cursor(tweepy.API(auth).search_tweets, q=&quot;Mr. Trash Wheel&quot;, tweet_mode=&#39;extended&#39;).items(100) # Loop through each tweet and extract desired data for tweet in tweets: location_info = { &#39;location&#39;: tweet.user.location } location_data.append(location_info) # Search for tweets containing the search term tweets = tweepy.Cursor(tweepy.API(auth).search_tweets, q=&#39;Mr. Trash Wheel&#39;, tweet_mode=&#39;extended&#39;).items(100) # Loop through each tweet and extract desired data for tweet in tweets: text_info = { &#39;text&#39;: tweet.full_text } text_data.append(text_info) # Combine lists into a dictionary data = {&#39;date&#39;: date_data, &#39;location&#39;: location_data, &#39;text&#39;: text_data} # Store results in pandas dataframe df = pandas.DataFrame(data) # Print dataframe print(df) 3.10.2 Questions Create an AI prompt that fixes any formatting issues with the code that would cause it not to run. Devise an AI prompt that removes any dead code from your sample above. What gets removed? Create a prompt that makes the code less repetitive, adhering to the DRY principle. What aspect of the code was repetitive? Construct a prompt that makes the code more concise. What are some trade-offs that appear in this code between readability and brevity? "],["annotating-your-code.html", "Chapter 4 Annotating Your Code 4.1 Improves readability 4.2 Improves the quality 4.3 Examples of quality aiding comments 4.4 AI in Code Annotation 4.5 Ethics of using AI to annotate code 4.6 Examples on using AI for annotation 4.7 Summary", " Chapter 4 Annotating Your Code Code annotation, also known as code commenting, is the process of adding explanatory notes to source code. These notes are used to provide context, clarify functionality, and aid in understanding for developers who may be working on the codebase in the future. Code annotation is an important practice for any developer looking to write clear, efficient, and maintainable code. There are many benefits to annotating code. 4.1 Improves readability First, it can help to improve the readability of code. By adding comments, developers can explain the purpose of each section of code, which can make it easier for others to understand what the code is doing. This can be especially helpful for large or complex codebases, where it can be difficult to keep track of all the different components. This is particularly important in contexts where the original developer of a project may move on to something else and others are left to work on them. Annotation perhaps most often helps a developer remember things they knew about the code when they were originally writing it (annotation is helpful for future you!) If the original developer left well-annotated code, it can drastically improve the ability of others (and their future selves) to continue with the project. 4.1.1 Examples of readability aiding comments Comments that help readability clarify what the code is doing Function explanations: A comment at the beginning of a function or method can describe its purpose, parameters, and expected return values. This makes it easier for others to understand what the function does and how to use it. # This function calculates the sum of two numbers def add_numbers(x, y): return x + y Inline explanations: Use inline comments to explain what a specific line or block of code does. This can help someone reading your code to quickly understand what’s going on. # Loop through each item in the list for item in my_list: # Check if the item is greater than 10 if item &gt; 10: # Print the item print(item) TODO comments: Use TODO comments to mark areas of your code that need further work or improvement. This can help you or others to remember to come back to a specific part of the code. # TODO: Implement error handling for this function def my_function(): pass Parameter descriptions: If a function or method has complex parameters, it can be helpful to add comments explaining what each parameter does. def my_function(parameter1, parameter2): &quot;&quot;&quot; Calculate the sum of two numbers. Parameters: parameter1 (int): The first number to be added. parameter2 (int): The second number to be added. Returns: int: The sum of parameter1 and parameter2. &quot;&quot;&quot; return parameter1 + parameter2 Code block summary explanations: If you have a long or complex code block, you can add a comment to explain what the block is doing. # This code block creates a dictionary containing the counts of each word in a list of text strings word_counts = {} for text in text_list: for word in text.split(): if word not in word_counts: word_counts[word] = 0 word_counts[word] += 1 4.1.2 Improves maintainability Code annotation can help to improve the maintainability of code. By adding comments, developers can explain the reasoning behind certain decisions, which can make it easier for others to make changes to the code without breaking it. This can be especially helpful when multiple developers are working on the same codebase, as it can help to prevent conflicts and ensure that the code is always in a consistent state. 4.1.3 Examples of maintainability aiding comments Comments that help maintainability explain why the historical decisions of why code was made the way it was Examples of maintainability aiding comments Design decisions: If there were specific design decisions made when creating the code, you can add comments explaining why certain choices were made. bash # We chose to use a linked list data structure for this function to reduce the time complexity of inserting and deleting elements. Legacy code: Sometimes, code may have been written in a certain way due to constraints or limitations at the time it was created. Adding comments to explain this can help others understand why the code is the way it is. # This code was written before Python 3, which introduced the `yield from` syntax. Therefore, we used a `for` loop to iterate over the nested list. Performance optimizations: If certain performance optimizations were made to the code, you can add comments explaining why they were necessary. bash # We used memoization to improve the time complexity of this recursive function, as it was taking too long to execute for larger inputs. Compatibility considerations: If the code was written with compatibility considerations in mind, you can add comments explaining why certain choices were made. # We used the `os.path` module to ensure that this code will work on both Windows and Unix-based systems, as the path separators are different on each platform. Limitations: If there are limitations or edge cases that the code cannot handle, you can add comments to explain this to others. # Note that this function assumes that the input array is sorted in ascending order. If the array is unsorted, the results may be incorrect. 4.2 Improves the quality Code annotation can help to improve the quality of code. By adding comments, developers can identify potential issues or edge cases, which can help to prevent these issues from occurring in the first place. This can be especially helpful when testing code, as it can help to ensure that the code is working as expected. 4.3 Examples of quality aiding comments Comments that help improve the quality of the code by explaining to other how to use or help improve it Error handling: Adding comments to explain how and why error handling is being implemented can help ensure that your code is robust and able to handle unexpected inputs or errors. This helps others know how the code was intended to be used. # If the input argument is not a list or is empty, raise a ValueError if not isinstance(input_list, list) or len(input_list) == 0: raise ValueError(&quot;Input list cannot be empty&quot;) Complexity: If your code has particular complexities, adding comments that explain it can help others understand the performance characteristics of your code. It may help others identify whether there is a simpler way to write the code. By adding a comment that expresses uncertainty about the code and asking for suggestions, the author can potentially receive feedback from others on how to improve the code. # This block of code could probably be simplified, but I&#39;m not sure how. new_list = [] for i in old_list: if i &gt; 0: new_list.append(i) Constants and variables: Adding comments to explain the purpose of constants and variables can make your code easier to use. It not only notifies others of the variables existence but lets them know if they need to change the parameters for their own purposes. # This constant represents the maximum allowed number of retries when attempting to connect to the server. MAX_RETRIES = 3 # This variable tracks the number of failed attempts to connect to the server. num_retries = 0 Code organization or disorganization: Adding comments to explain the organization and structure of your code can make it easier for others to navigate and may bring out a better organizational strategy for your code. # Define helper functions for data processing def preprocess_data(input_data): # Implementation details def analyze_data(processed_data): # Implementation details def visualize_data(analyzed_data): # Implementation details # Load data from file input_data = load_data(&quot;input.txt&quot;) # Preprocess data processed_data = preprocess_data(input_data) # Analyze data analyzed_data = analyze_data(processed_data) # Visualize data visualize_data(analyzed_data) Assumptions and constraints: Adding comments to explain the assumptions and constraints of your code can help others understand its limitations and potential pitfalls. # This function assumes that all input values are positive integers. Negative or non-integer inputs may result in unexpected behavior. 4.4 AI in Code Annotation We’ve discussed why code annotation and documentation are important, but when and why would you use AI for code annotation? AI can be a nice tool to supplement the annotation of your code. It should not be the only source of annotation for your code, because as the code author, you need to verify that what AI has annotated is consistent with your knowledge and history of development of the code. But using AI to annotate your code can be useful to supplement existing code annotations or to annotate old code that was poorly annotated either by yourself or others who are no longer working on the project. Here are some of the benefits of using AI for code annotation: Speed and efficiency: AI algorithms can analyze code much faster than humans, which means they can quickly generate comments and annotations for large codebases. This can save developers significant time and effort, allowing them to focus on other aspects of the development process. Consistency: Unlike humans, AI is not affected by personal biases or preferences, so it can provide consistent annotations across different code files and projects. This can help ensure that all code in a project is well-documented and easy to understand. Objectivity: AI can analyze code objectively and identify potential issues that may have been missed by humans. This can lead to better quality code that is easier to maintain and less prone to errors. Learning: AI models can learn from large datasets of annotated code and improve their ability to generate comments and annotations over time. This means that the more code the AI model analyzes, the more accurate and effective it becomes at annotating code. Specificity: AI models can be trained on specific programming languages, frameworks, or libraries, allowing them to generate language-specific comments and annotations that are tailored to the needs of the project. This can be particularly helpful for large, complex projects that require specialized knowledge or expertise. 4.5 Ethics of using AI to annotate code However, there are also a number of potential ethical concerns associated with using AI to annotate code. For example, we don’t yet know how and it what ways AI models may be biased. Additionally, AI models may be opaque, which could make it difficult to understand why they made certain annotations. Finally, because AI models are not humans and don’t necessarily tell the stories behind the code, they may be used to generate annotations that are not accurate, helpful, or do not tell the full depth of the history of what occurred with the code, which could lead to problems. Given these potential benefits and concerns, it is important for users of AI to always realize that they are ultimately accountable for the annotation that AI model makes and careful review of this annotation is needed. There are a number of ethical considerations to take into account when using AI to annotate code. Here are a few of the most important ones: Accountability: First and foremost, a user of AI is always primarily accountable for any output that they use from an AI model. AI models can give you annotation to start with, but it is up to you as the user to verify and review this output carefully. The user of the AI model is ultimately responsible keeping or throwing out the annotations the AI makes and thus is responsible for using errors that the model makes. Much like a user of a Google Search engine is responsible for which results they use, a user of AI is responsible what output from the AI model they use. Transparency: It is important to be transparent about the use of AI in code annotation. This means disclosing the fact that AI is being used, as well as the specific AI model and dataset that is being used. This should be stated on every file where annotation has been made using AI. This transparency allows others who view the code to be able more fully interpret the AI-created annotation that accompanies the code. Bias: AI models are trained on data, and this data can introduce bias into the model. It is important to be aware of the potential for bias and to take steps to mitigate it. This can be done by using a diverse dataset, by carefully selecting the features that are used to train the model, and by using techniques such as adversarial training. TODO: How does this relate to annotation? Explainability: It is important to be able to explain the decisions that an AI model makes. This is especially important in the case of code annotation, where the decisions made by the AI model can have a significant impact on the quality of the code. There are a number of techniques that can be used to explain the decisions of an AI model, such as visualization and rule extraction. 4.6 Examples on using AI for annotation 4.6.1 Ask for a README summary To try out some annotation with code examples, this author dug up some old code that she has no idea what it does because time has passed and at the time she didn’t document it very well. First, I wanted ChatGPT to make a README for me. README’s are a standard file that explain what the code base does and provides a summary of what is happening in the set. I asked ChatGPT if it could: Create a README for this code and then I pasted the old code. ChatGPT gave me some output that generally looked like a README: This README seems accurate given the work I was doing at the time. But obviously the title isn’t great – it doesn’t describe the code well. Plus there’s not really information about usage or outputs of the code. So I asked it: Can you make this README more succinct and with sections about how you would use this code? This yielded a much better result. 4.6.2 Ask for line by line annotation Second, I wanted to have ChatGPT annotate code line by line. So I asked it Can you annotate some R code for me? It not only provided helpful annotations but it fixed spacing and added more spaces between lines of code: It does however, think the code is Python apparently if we look in the upper left corner. But this doesn’t seem to have affected its accuracy in its annotations. 4.6.3 Ask for how the code could be improved This code is old, and I don’t think it runs properly and is in no way reproducible. So I wanted to see what ChatGPT would recommend for improvements to the code. I said How could I make this code better? It had a lot of great advice: First and foremost it told me my variable names are not consistent and also not descriptive. Which is completely accurate! There’s variable names like xx and ll which don’t tell the reader anything about the variable. 4.6.4 Style the code Next, I asked chatGPT if it could restyle the code into tidyverse style. It definitely put elements that look like tidyverse however, it also put items in the code that I can tell by looking at it won’t work. So I tried to tell it about the errors: :::{.query} This code is close but there are some errors. tidyverse functions don’t work with matrices ::: and it told me: You are correct that the tidyverse functions are designed to work with data frames and not matrices. Here&#39;s a modified version of your code that converts the matrix to a data frame and uses tidyverse functions: The lesson here is that the output of chatGPT still needs to be vetted by the person asking for it. It is a great idea to continue to have AI’s work on something if it isn’t quite what you are asking for, however, at the end of the day it is you, the human, who has to vet the output. 4.6.5 Sometimes it has trouble with file types if given a URL Copying and pasting code appears to be the best way to go at this point in time. I asked chatGPT if it could annotate code in a Jupyter notebook at a URL I gave it: Can you annotate the code at this URL? https://github.com/jhudsl/reproducible-python-example/blob/main/make_heatmap.ipynb It responded with some of the code at that file where it was annotated but most of the notebook was not there. I told ChatGPT: That isn’t all the code at that url ChatGPT told me: You&#39;re right, I apologize. The code at the given URL is actually in a Jupyter Notebook format, so it&#39;s not easy to copy-paste here. However, I can suggest an alternative approach: you can use the website nbviewer (https://nbviewer.jupyter.org/) to view the notebook and its code. Here are the steps to do so: Go to https://nbviewer.jupyter.org/ Paste the URL of the notebook ( https://github.com/jhudsl/reproducible-python-example/blob/main/make_heatmap.ipynb ) into the &quot;Enter the location of a Jupyter Notebook&quot; field and press &quot;Go&quot;. This will display the notebook and its code, and you can read through it and add your own annotations as needed. I hope this helps! This was a nice tool to recommend, however it still told me I should add my own annotations at the end of this. 4.7 Summary Code annotation is important for readability, maintainability, and overall quality of code AI can be a helpful tool for supplementing annotations or creating annotation for poorly annotated code. Ultimately the code author who uses AI as a tool for annotation is still ultimately responsible for verifying that the annotations are consistent with their knowledge of the code. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-25 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## curl 4.3 2019-12-02 [1] RSPM (R 4.0.3) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## highr 0.8 2019-03-20 [1] RSPM (R 4.0.3) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## httr 1.4.2 2020-07-20 [1] RSPM (R 4.0.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["understanding-unfamiliar-code.html", "Chapter 5 Understanding Unfamiliar Code 5.1 Using AI to understand code 5.2 Example One: Summarizing Code You Didn’t Write 5.3 Example Two: Identifying a Coding Language 5.4 Example Three: Interpreting Regex 5.5 Example Four: Demystifying Functions 5.6 Example Five: Deciphering Comments 5.7 Hands-On Exercise [WORK IN PROGRESS]", " Chapter 5 Understanding Unfamiliar Code As a programmer, you will frequently encounter situations where you need to read and understand code written by other developers. This could be because you are collaborating on a project, you have taken over maintenance of an existing codebase, or you are learning new syntax or skills that require reading example codes. Comprehending code written by someone else is a distinct skill from being able to write your own code, and it takes practice to become proficient at it. Reading unfamiliar code is like exploring an unfamiliar city without a map or a guide. Just like in a new city, you may not know where to start or how to navigate the codebase. You may encounter unfamiliar syntax, functions, and libraries that you have never seen before, just as you might encounter new streets, buildings, and landmarks. At first, you may feel disoriented and overwhelmed, and may need to spend some time getting oriented and familiarizing yourself with the environment. As you explore, you may start to see patterns and similarities, just as you might begin to recognize neighborhoods and landmarks in a new city. You may also encounter dead-ends, confusing intersections, and unexpected detours, just as you might encounter bugs and errors in the code. To make progress in this unfamiliar territory, you may need to rely on a combination of intuition, deduction, and experimentation. You may need to break down the code into smaller pieces, analyze the behavior of each piece, and gradually build up a mental model of how the code works. You may also need to consult documentation, online resources, or other experts who are familiar with the codebase, just as you might ask locals or consult a map in a new city. In the end, with patience, persistence, and a willingness to learn, you can successfully navigate the unfamiliar code and achieve your goals, just as you can successfully explore a new city and discover its hidden treasures. Learning how to read and understand code written by someone else is a valuable skill that can help you be a more effective programmer. By being able to read and comprehend unfamiliar code, you can contribute to projects more quickly, diagnose and fix bugs more effectively, and learn new programming techniques and best practices. As with any skill, the more you practice reading and understanding code written by others, the more comfortable and proficient you will become at it. 5.1 Using AI to understand code While anyone can learn to understand code written by someone else, using AI language models to achieve this has three significant advantages. Summarize large codebases. AI can quickly scan large codebases and give you a high-level overview of what they do. This can save you a lot of time and effort, especially when dealing with complex codebases. For example, AI can identify the main functions and classes in a codebase, and it can show you how they are related. Analyze the code. AI can look at the code and tell you about its structure, complexity, and potential defects quickly and efficiently. This can help you understand the code better and make it easier to maintain and improve. For example, AI can identify parts of the code that are difficult to understand or maintain, and it can suggest ways to improve the code. Understand comments and documentation. AI can read comments and documentation written by other developers. This can help you understand the code’s purpose and the assumptions and limitations of the codebase. For example, AI can identify the key assumptions that are made in the code, and it can explain the trade-offs that were made in the design of the code. Keep these ethical considerations in mind when using AI to summarize code. Who owns the code? If you are not the owner of the code, you should get permission from the owner before summarizing it. What is the purpose of the summary? If you are summarizing the code for educational or research purposes, it is likely ethical to do so. However, if you are summarizing the code for commercial purposes, you may need to get permission from the owner. Does the code contain any sensitive or personal information? If the code contains any sensitive or personal information, you should take special care to protect that information. 5.2 Example One: Summarizing Code You Didn’t Write Here’s some simple code using the R programming language, written by an unnamed programmer. If you are familiar with R, you might be able to understand what this code does with little effort. However, if you don’t know R, you’re relatively new to R, or you’re just having a bad day, understanding what this bit of code can take a great deal more energy and time. AI language bots can ease that burden. library(tidyverse) d &lt;- ggplot2::diamonds d_sel &lt;- d %&gt;% select(carat, cut, color, clarity, depth, table, price) d_fil &lt;- d_sel %&gt;% filter(price &gt; 5000) d_bin &lt;- d_fil %&gt;% mutate(carat_bins = cut_width(carat, width = 0.2)) d_summ &lt;- d_bin %&gt;% group_by(carat_bins, cut, color, clarity) %&gt;% summarize(mean_price = mean(price), sd_price = sd(price)) We first ask Claude-instant (as implemented by Poe) to explain the purpose of this code. “What does this code do?” You can ask for Claude to summarize each step in detail as well. “Can you explain what each step does in detail?” Maybe you’ve never worked with the tidyverse package in R - Claude can tell you about it. “What is the tidyverse package?” You might also not be familiar with the diamonds dataset (especially if you’ve never used it before) and want some clarification on where the data are from. “Can you tell me more about the diamonds dataset?” 5.3 Example Two: Identifying a Coding Language Sometimes you might have to work with legacy code. Legacy code can be difficult to work with, especially if it is written in a language or style with which you are not familiar. There are more than 700 programming languages in use today, so it is impossible for any programmer to know them all. AI can be a helpful tool for identifying the language and version of legacy code, which can make your life just a little easier. Let’s look at example code that might have been written decades ago. program temperature_smog_analysis; uses Math; const n_temperatures = 1000; n_smog_measures = 500; type TemperatureArray = array[0..n_temperatures-1] of integer; SmogArray = array[0..n_smog_measures-1] of integer; var temperatures: TemperatureArray; smog_measures: SmogArray; combined_data: array of integer; slope, y_intercept: double; i, j: integer; function connect_to_database(filename: string): integer; begin { implementation of connect_to_database function } end; function retrieve_temperatures(fd: integer): integer; begin { implementation of retrieve_temperatures function } end; function retrieve_smog_measures(fd: integer): integer; begin { implementation of retrieve_smog_measures function } end; function retrieve_temperature(fd, index: integer): integer; begin { implementation of retrieve_temperature function } end; function retrieve_smog_measure(fd, index: integer): integer; begin { implementation of retrieve_smog_measure function } end; procedure close_database(fd: integer); begin { implementation of close_database function } end; We can ask Bard to take a guess at what the coding language might be. “What language is this code written in?” We can explore further to figure out what indicators tell Bard the language is Pascal. “How do you know this is Pascal?” It turns out there are multiple versions of Pascal. Since you will presumably need to work with this legacy code, you might want to know which version it is. “What version of Pascal is this?” 5.4 Example Three: Interpreting Regex Regex (short for Regular Expressions) is a powerful tool used to describe patterns in text. It’s a sequence of characters that define a search pattern. Regular expressions can be a powerful tool for data cleaning, text mining, and data validation. They are widely used in web development, data science, and other fields where text processing is important. They can also be tricky to understand at first because they involve a specific syntax that can be complex. We can use ChatGPT to explain regex in a bit of someone else’s code. x = sub(&quot;/d/e&quot;,&quot;/d&quot;,x) “What does this do?” 5.5 Example Four: Demystifying Functions Sometimes we get handed code that includes complex architecture. Perhaps you are working with code you wrote years ago when you really liked loops, but present you finds them difficult to parse. (Be nice to past you - maybe you were a baby programmer and didn’t know better.) Instead of giving yourself a headache, you could turn to ChatGPT to explain what your old code does. def my_function(x): result = x for i in range(10): for j in range(5): result = result + 2 * (i + 1) * (j + 1) * (i % 2 == 0 and j % 2 == 0) - 1 return result “What does this function do?” Well, now you have an idea what past-you might have been attempting to do with this code. You can also query AI about the potential problems from using the code as-written. “What are some possible issues with this code?” (And if you do ever run across an expression like this in your code, you can check out our chapter on refactoring code using AI to fix it!) 5.6 Example Five: Deciphering Comments 5.7 Hands-On Exercise [WORK IN PROGRESS] Now it’s your turn to try. Let’s say you were handed this bit of code to work with (and eventually modify), but first you need to figure out what’s going on with it. Unfortunately, the original programmer left very little in the way of notes or annotation. Note: This code is just an example and was written strictly for educational purposes. use ode_solvers::{Euler, OdeMethod}; use plotters::prelude::*; use std::fs::File; const N: f64 = 1000000.0; const I0: f64 = 10.0; const R0: f64 = 0.0; const S0: f64 = N - I0 - R0; const BETA: f64 = 0.3; const GAMMA: f64 = 0.1; fn sir_model(t: f64, y: &amp;[f64], v: f64) -&gt; Vec&lt;f64&gt; { let s = y[0]; let i = y[1]; let r = y[2]; let dsdt = -BETA * s * i / N - v * s; let didt = BETA * s * i / N - GAMMA * i; let drdt = GAMMA * i + v * s; vec![dsdt, didt, drdt] } fn main() { let mut solver = Euler::new(sir_model); solver.set_initial_condition(&amp;[S0, I0, R0]); let root = BitMapBackend::new(&quot;sir_vaccination.png&quot;, (800, 600)).into_drawing_area(); root.fill(&amp;WHITE).unwrap(); let mut chart = ChartBuilder::on(&amp;root) .caption(&quot;SIR model with vaccination&quot;, (&quot;sans-serif&quot;, 40)) .set_label_area_size(LabelAreaPosition::Left, 60) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0.0..100.0, 0.0..N) .unwrap(); let mut data1 = vec![]; for _ in 0..1000 { let y = solver.integrate(0.1, 0.0); data1.push((solver.time(), y[0], y[1], y[2])); } let vac_rate = 0.1; let vac_coverage = 0.5; let vac_num = vac_coverage * N; let mut data2 = vec![]; for i in 0..1000 { let t = i as f64 * 0.1; let v = if t &gt;= 50.0 &amp;&amp; t &lt; 150.0 {vac_num * vac_rate} else {0.0}; let y = solver.integrate(0.1, v); data2.push((solver.time(), y[0], y[1], y[2])); } chart .configure_mesh() .x_labels(10) .y_labels(10) .disable_x_mesh() .disable_y_mesh() .draw() .unwrap(); chart .draw_series(LineSeries::new( data1.iter().map(|d| QUESTIONS: What language is the code written in? What are two clues that tell you the language? What version of the language is it? What is the overall task this code does? ANOTHER QUESTION??? What does this code snippet do? let root = BitMapBackend::new(&quot;sir_vaccination.png&quot;, (800, 600)).into_drawing_area(); Why would a programmer set up a section of code like this? fn sir_model(t: f64, y: &amp;[f64], v: f64) -&gt; Vec&lt;f64&gt; { let s = y[0]; let i = y[1]; let r = y[2]; let dsdt = -BETA * s * i / N - v * s; let didt = BETA * s * i / N - GAMMA * i; let drdt = GAMMA * i + v * s; vec![dsdt, didt, drdt] } How are these variables initialized? let s = y[0]; let i = y[1]; let r = y[2]; What are some other variables that could be added to this command to customize the output? chart .configure_mesh() .x_labels(10) .y_labels(10) .disable_x_mesh() .disable_y_mesh() .draw() .unwrap(); devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-25 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## curl 4.3 2019-12-02 [1] RSPM (R 4.0.3) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## here 1.0.1 2020-12-13 [1] CRAN (R 4.0.2) ## highr 0.8 2019-03-20 [1] RSPM (R 4.0.3) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## httr 1.4.2 2020-07-20 [1] RSPM (R 4.0.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.2) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## png 0.1-8 2022-11-29 [1] CRAN (R 4.0.2) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## rappdirs 0.3.3 2021-01-31 [1] CRAN (R 4.0.2) ## Rcpp 1.0.10 2023-01-22 [1] CRAN (R 4.0.2) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## reticulate 1.28 2023-01-27 [1] CRAN (R 4.0.2) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["appendix.html", "Appendix Additional Programming Languages", " Appendix Additional Programming Languages You might also encounter these programming languages on your software journey. Julia Julia is designed for numerical and scientific computing, data analysis, and machine learning. It has a syntax that is easy to learn and read, making it an ideal choice for data scientists, engineers, and researchers. Julia code can also be compiled to native machine code using the Julia compiler. Because Julia is a relatively new language, it has fewer add-on libraries and resources available compared to more established languages. MATLAB MATLAB is a high-level programming language and development environment commonly used for numerical computation, data analysis, and visualization. It is widely used in engineering, physics, and finance, among other fields. It is generally considered to have a user-friendly syntax and is relatively easy to learn compared to other languages. MATLAB has a development environment called MATLAB Compiler that allows you to package MATLAB code into standalone executables or shared libraries for use on a wide variety of operating systems. Fortran Fortran has been around for decades and has a long history in scientific and engineering communities. It has a more challenging syntax and is considered harder to learn than some of the other languages on this list. It is primarily used for scientific and engineering applications that require numerical computations and simulations such as computational physics, weather forecasting, and computational chemistry. Rust Rust is a systems programming language that focuses on speed, reliability, and memory safety. It is commonly used for developing performance-critical software, such as operating systems, web browsers, and game engines. Rust’s syntax is similar to C++, but is often considered to have a steeper learning curve due to its focus on memory safety and ownership concepts. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
