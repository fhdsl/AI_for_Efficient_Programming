[["index.html", "Using AI for Software About this Course 0.1 Available course formats", " Using AI for Software April, 2023 About this Course 0.1 Available course formats This course is available in multiple formats which allows you to take it in the way that best suites your needs. You can take it for certificate which can be for free or fee. The material for this course can be viewed without login requirement on this Bookdown website. This format might be most appropriate for you if you rely on screen-reader technology. This course can be taken for free certification through Leanpub. This course can be taken on Coursera for certification here (but it is not available for free on Coursera). Our courses are open source, you can find the source material for this course on GitHub. 0.1.1 Testing query css something here "],["introduction.html", "Chapter 1 Introduction 1.1 AI provides new opportunities 1.2 AI code of ethics 1.3 The AI chatbots 1.4 About this book", " Chapter 1 Introduction The increasing availability of AI chatbots is creating a new landscape in software development. While the future of those who work with code is uncertain, there are valid concerns about the potential for AI bots to replace or significantly reduce the workload of programmers, resulting in a loss of job opportunities. Additionally, there are significant ethical and privacy concerns regarding the use of training data sets to teach these AI systems. Despite these worries, the widespread adoption of AI bots is ushering in a new era of computing, data science, and information interaction that presents many exciting possibilities. As AI bots become more ubiquitous, they have the potential to change the way we work with information and interact with machines. The rapid development of AI technology is creating exciting opportunities for programmers to develop innovative solutions to previously intractable problems. Ultimately, while the future of software development is unclear, there is much to be optimistic about in this brave new world. The advancements in AI and chatbot technology present an opportunity for programmers to work alongside algorithms to create innovative solutions that were previously unimaginable. As with any technological revolution, there will be challenges, but it is up to us to work together to ensure that we use these tools ethically and responsibly, and to create a future that benefits everyone. 1.1 AI provides new opportunities We do not believe that AI chatbots will replace software developers. While AI can be powerful and useful, it is only as good as the training data behind it and the human using it. Therefore, for the time being and the foreseeable future, humans will remain at the forefront of programming innovation, with AI providing valuable support. As new code is often built on top of existing code written by humans, it is unlikely that AI will fully replace the need for human programmers. However, we do think that the roles of programmers in software development are changing, and some of the skills required to work in this new environment are slightly different from those needed before. In addition to proficiency in programming syntax, programmers may need to develop a more refined ability to construct queries that enable AI bots to create the desired workflows. Other critical skills such as debugging, troubleshooting, and documentation will continue to be valuable, and can be enhanced through the use of AI. Furthermore, AI creates new opportunities and niches for tasks that were previously difficult, time-consuming, or impossible. This is an exciting time for those working in programming, with great potential to explore new and innovative solutions. As AI technology continues to advance, its role in programming will only become more significant, and it is up to developers to adapt and learn how to use these new tools effectively. We asked OpenAI’s ChatGPT whether AI chatbots would replace human software developers and programmers, and this was the response: “No, ChatGPT is not replacing human software developers and programmers. While ChatGPT is capable of generating code, it is not a substitute for the skills and expertise of human programmers. Software development is a complex process that requires a deep understanding of programming languages, algorithms, and software design principles. Human programmers have the ability to not only write code, but also to understand the nuances of different programming languages and frameworks, debug code, and optimize performance. Furthermore, programming is not just about writing code - it also involves understanding and translating business requirements into technical solutions, collaborating with other team members, and maintaining code over time. While ChatGPT can be used to automate certain aspects of software development, it cannot replace the creativity, problem-solving skills, and domain expertise of human software developers and programmers.” 1.2 AI code of ethics Our first duty as programmers is to avoid causing harm to people and the world. This includes avoiding both intentional and inadvertent harm. Intentional harm is harm that is caused by a programmer’s deliberate actions. For example, a programmer might create a virus that is designed to harm computers. Inadvertent harm is harm that is caused by a programmer’s negligence or lack of foresight. For example, a programmer might create a program that is buggy and causes data loss. We must always be aware of the potential for harm and deliberately take steps to mitigate it. This includes things like: Be aware of the potential for bias. AI systems are trained on data, and that data can reflect the biases of the people who collected it. Programmers should be aware of the potential for bias in their data and take steps to mitigate it. Be transparent about your work. Share information about your code, data, and algorithms. This will help others to understand how your work works and to identify any potential problems. Be accountable for your work. Take responsibility for the consequences of your code. Be willing to make changes if necessary. Participate in discussions about AI ethics. There are many online and in-person communities where you can discuss the ethical implications of AI with other people. Advocate for ethical AI. Speak up when you see AI being used in a way that you believe is unethical. Support organizations that are working to promote ethical AI. 1.3 The AI chatbots Although humans have been interacting with AI chatbots for years, the popularity of OpenAI’s ChatGPT and DALL-E programs has sparked a recent surge of interest in them. We will use a variety of chatbots as examples throughout this course. Some AIs will be better suited for your particular tasks, and it is too early to judge which of the technologies will end up dominating the industry. We encourage you to test multiple AI platforms to find the ones that best fit your needs, and the use of a particular AI in each chapter should not be taken as an endorsement by us. ChatGPT is OpenAI’s large language model based on the GPT (Generative Pre-trained Transformer) architecture. It is designed to understand and generate human-like responses to text-based conversations. You will need to create an account before using it. Bard is Google’s large language model, also known as a conversational AI or chatbot trained to be informative and comprehensive. It is trained on a massive amount of text data and is able to communicate and generate human-like text in response to a wide range of prompts and questions. You will need to join the waiting list before getting access, although in our experience the wait time is short. Poe is Quora’s platform that gives you access to multiple AI chatbots, including Sage, based on OpenAI’s GPT-3.5 architecture; Claude, an AI natural language bot created by Anthropic; and Ehang’s AI platform, which was created to interface with their Dragonfly drone. Poe also gives you access to ChatGPT. 1.4 About this book We used AI bots (including ChatGPT, Bard, Sage, and Claude) to develop and write much of this course. We firmly believe this new technology can be used in ethical ways and we put into practice all the rules and suggestions offered over the following modules. It is up to the human behind it to make sure that AI is used properly and transparently. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-14 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["writing-and-debugging-code.html", "Chapter 2 Writing and Debugging Code 2.1 Using AI to write code 2.2 The Basics 2.3 Selecting a Language: 2.4 Prompt Generation:", " Chapter 2 Writing and Debugging Code In today’s digitally-driven world, coding has become an essential skill. It is used to create websites, mobile applications, and sophisticated software systems. Contrary to popular belief, coding is not only for those who possess an innate talent for programming. With the right resources and a willingness to learn, anyone can become proficient in coding. Practice is crucial to mastering the art of coding, and those who are willing to commit themselves to the learning process can achieve great results. Writing code can also be a rewarding and fulfilling hobby, too. Creating your own software, building a website, or automating a task can be immensely satisfying, and can provide a sense of accomplishment and pride. Moreover, writing code can be a form of creative expression. Just as musicians use notes to compose music and artists use paint to create visual art, programmers use code to create digital experiences. From building websites to creating video games, code can be used to bring ideas to life in exciting and innovative ways. Ultimately, the ability to write code is a valuable asset in today’s world, with increasing demand for skilled programmers in a wide range of industries. Whether as a career or hobby, coding can be both personally and professionally rewarding. The accessibility and versatility of coding make it an excellent skill for anyone to learn, regardless of their background or previous experience. 2.1 Using AI to write code AI-powered programming tools and technologies are revolutionizing the way we approach software development. AI can be used to generate code snippets, which can save developers significant amounts of time and increase productivity. This is because AI can analyze existing code and learn from it to generate code that is similar to what a human programmer might write, but in a fraction of the time. Additionally, AI makes it possible for people to write code in languages with which they are only slightly familiar. AI can also provide guidance and suggestions for human programmers. For example, an AI-powered code editor might suggest more efficient algorithms or highlight potential errors in real-time. This can help reduce the number of bugs and errors in code, leading to better performance and a more efficient development process. One of the most promising aspects of AI-powered programming is its potential to make programming more accessible to a wider range of people. With AI-generated code and automated programming tools, individuals who are not experienced developers can still create software solutions. This has the potential to democratize programming and lead to new innovations from a wider range of people. The rise of AI technologies is transforming software development and changing the skills required for writing code. Rather than simply memorizing syntax, developers need to focus on developing their creativity, intuition, and problem-solving skills. Additionally, programmers must also hone their abilities in architecture design and project management, as these skills are becoming increasingly important in the modern software development landscape. The use of artificial intelligence (AI) in coding has raised a number of ethical concerns. One of the biggest concerns is the potential for AI to create biased or harmful code. AI systems are trained on data created by humans. If this data used to train the system is biased, the resulting code could also be biased. This could lead to discrimination against certain groups of people, such as those with certain ethnic or cultural backgrounds, genders, or ages. Another major concern is the use of AI to generate malicious code. For instance, AI could be used to create code that spreads malware or hacks into computer systems. This could cause severe damage to individuals and organizations, including data breaches and financial losses. When AI systems are trained on data, they may also learn and incorporate code from that data. This means that AI-generated code could potentially infringe on the copyright of the original author of the code. For example, if an AI system is trained on a GitHub repository that contains code written by a human programmer, the AI system could generate code that is identical to or similar to the code in the GitHub repository. If the AI system then uses this code without permission from the original author, this could constitute copyright infringement. In general, we want programmers to feel comfortable sharing their code openly without fear they won’t be credited. Similarly, AI systems could potentially infringe on intellectual property rights by using code that is protected by trademarks or patents. For example, if an AI system is trained on a training manual that contains code that is protected by a trademark, the AI system could generate code that is identical to or similar to the code in the training manual. If the AI system then uses this code without permission from the trademark owner, this could constitute trademark infringement. There is also a risk that AI-generated code could be unintelligible to humans. This could make it difficult to understand how the code works and could make it hard to identify and fix any issues that may arise. This could result in negative consequences, such as system crashes or security breaches, that could have been avoided if the code had been written by a human programmer. It is essential to address these ethical concerns and ensure that the use of AI in coding is done in a responsible and transparent manner. This could be done through ensuring the quality of the data used to train AI systems, promoting transparency in AI-generated code, and implementing safeguards against the creation of harmful or biased code. By doing so, we can harness the potential of AI to improve and transform the way we write and optimize code while maintaining ethical standards. As a programmer using AI, it is up to you to be responsible for what you create. You must rigorously test any code you write and also take care that you are only using code that you’re authorized to use. This means asking the AI chatbot where code snippets are from and tracking down those citations and authorizations yourself (instead of just trusting the AI that everything is okay). Here are some additional tips for using AI responsibly in coding: Be aware of the potential biases in the data that is used to train AI systems. Make sure that you understand the code that you are using, even if it was generated by AI. Be careful about what code you share publicly, as it could be used for malicious purposes. Obtain permission from the copyright holders of any code that you use to train the AI system. Only use code that is in the public domain or that has been licensed for use by the AI system’s owner. Cite any GitHub repositories or training manuals you might use in your code 2.2 The Basics Using AI to write code is as much of an art as writing your own code. You can jump right in and ask your AI chatbot to write the code, but you’re unlikely to be successful and incredibly likely to get frustrated. Before you start interacting with the AI, you need to plan out what you want to do. Following a few rules and suggestions will make your experience much more enjoyable and productive. The first rule about using AI is to remember that it cannot read your mind. You need to tell it what you’re thinking, and it may take several rounds of question-and-answer before you get something you can work with. Be clear about your goals. What do you want the AI to do? Be as specific as possible. Start with a simple task. Don’t try to do too much too soon. Start with a simple task and then gradually work your way up to more complex tasks. You wouldn’t write a complete program all at once, and you shouldn’t have AI do it, either. Provide enough data. The more data (and detail) you can give the AI, the better it will be able to learn and perform the task you want it to do. Be patient. Querying an AI can take time. Don’t expect it to be perfect right away. The second rule about using AI is to test everything. You are responsible for the code that AI generates, even if you didn’t write it yourself. AI can be biased, just like humans, and this could lead to sub optimal development. There is a concern that AI may focus development on areas that optimize certain metrics but not overall quality, effectiveness, or user needs. Human judgment is still needed to ensure that AI is used in a responsible and ethical way. Test your results. Make sure the AI is actually doing what you want it to do. AI systems are trained on data, and if the data is not representative of the real world, the AI system may not be able to generate code that works correctly. It is important to test the code to make sure that it is working as intended and that it is producing the desired results. Inadequate testing could lead to low quality, buggy code. Since AI generated code would be highly automated, it requires strong testing procedures and safety oversight to ensure it meets standards before deployment. Make sure your code is secure. AI systems can be used to generate code that is vulnerable to attack, and it is important to test the code to make sure that it is secure. This can help to prevent security breaches from occurring. Use a variety of AI models. There are many different AI models available. Experiment with different models to see which one works best for your task. Get feedback from others. Ask other people to review your code and give you feedback. This can help you identify and fix any problems with your code. 2.3 Selecting a Language: Selecting a language in which to develop software is an important first step. You might choose a language based on: Your preexisting knowledge or experience with the language A specific use case where the language is commonly used The language(s) your colleagues or coworkers use Here are commonly used languages and their typical use cases. Python Known for its readability, simple syntax, and comprehensive add-on modules. It is often recommended as a beginner-friendly language. Python is used for scientific computing, data analysis, machine learning, and web development. Many Data Scientist roles rely on Python. Ruby Similar to Python, Ruby is also known for its readability and user-friendly syntax. It is typically used for web development, building dynamic websites, and creating web applications. JavaScript A popular language for web development, known for its versatility and ease of use. Many of the interactive features of websites rely on JavaScript. Java Java is widely used for enterprise applications, android mobile apps, and web apps. PHP PHP is easy to learn but can become complex as the application grows. It is typically used for building dynamic web pages, web applications, and content management systems. R Used for statistical computing, data analysis, and data visualization, R is a popular choice for researchers and data scientists. Some beginners find its syntax complex, especially due to differences in the two major dialects: “base” R versus the “tidyverse”. Kotlin Kotlin is a relatively new language that is designed to be more concise and expressive than Java. However, its advanced features and concepts may be challenging for beginners. It is used for developing Android mobile apps, web development, and server-side development. Swift Used for iOS and macOS app development, Swift is known for its strict syntax and steep learning curve. C# Often used for Windows desktop applications, web applications, and video games, C# can be challenging due to its more complex syntax and strict type system. C++ A powerful language often used for developing high-performance applications and operating systems, C++ can be challenging to learn due to its complexity and the need to manage memory manually. You can find a description of other languages you might encounter here. 2.4 Prompt Generation: Create a set of prompts that will be used to guide participants in writing code in the selected language. These prompts should be specific enough to provide guidance, but open-ended enough to allow participants to exercise their creativity and problem-solving skills. For the example(s), walk participants through the process of interacting with ChatGPT and provide tips on how to refine their queries to get the best results. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-14 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["refactoring-code.html", "Chapter 3 Refactoring Code 3.1 AI in Code Refactoring 3.2 Example One: Correcting Syntax 3.3 Example Two: Styling and Convention 3.4 Example Three: Staying DRY 3.5 Example Four: Keeping Code Alive 3.6 Example Five: Making Code Readable 3.7 Example Six: Keep it Brief 3.8 Code optimization 3.9 Case studies / examples in industry (if any) 3.10 Common mistakes / edge cases / things to watch out for 3.11 Challenges / limitations 3.12 Hands-On Exercise", " Chapter 3 Refactoring Code Code refactoring is the process of improving the quality of underlying code without changing its functionality. In other words, it’s a way of cleaning up and optimizing code so that it’s easier to maintain and more efficient. This often involves making small changes to the code, such as renaming variables or functions, reorganizing code blocks, or simplifying complex expressions. Refactoring is an essential practice in software development and helps to ensure that the codebase remains manageable and adaptable as requirements and business needs change over time. Code refactoring helps to reduce technical debt, which is the accumulation of development work that needs to be done in the future as a result of taking shortcuts or using less than optimal solutions. Refactoring can help to identify potential issues and bugs before they cause problems, resulting in more stable software. Finally, refactoring code to be more readable and less verbose can create fewer headaches for you in the future. To understand why code refactoring is important, imagine trying to cook in a disorganized and cluttered kitchen. You might be a fantastic cook, but you are spending more time searching for utensils and ingredients, and the quality of the meal could suffer as a result. Similarly, code that is disorganized and cluttered can be difficult to work with and can result in lower-quality software. Refactoring is like cleaning and organizing the kitchen - it makes the process of cooking (or coding) smoother and more efficient. 3.1 AI in Code Refactoring Code refactoring has historically been done manually by developers. This involves reviewing code and identifying areas that could be improved or optimized, and then making changes to the codebase accordingly. Though important, this is process is time-consuming and labor-intensive, as it requires developers to carefully review every line of code to identify potential issues or areas for improvement. Additionally, manual code refactoring is error-prone, as developers can accidentally introduce bugs or errors into the codebase while making changes. However, AI has significant potential to help with code refactoring. AI can use machine learning algorithms to analyze large amounts of code and identify patterns or areas that could be improved. For example, they can identify sections of code that are redundant, overly complex, or difficult to maintain, and suggest changes that could be made to improve the codebase. Machine learning algorithms can also help to identify potential bugs or security issues in the codebase, which can help to improve the overall quality and stability of the software. AI refactoring is also faster and more accurate than manual refactoring. This is particularly useful for large-scale software projects with massive codebases, where manual code review and refactoring can be an enormous task. In the next sections, we’ll take a look at some examples of using AI to refactor code. 3.2 Example One: Correcting Syntax Programming languages operate using their established set of rules. For example, Python uses indentation to define code blocks. However, when you shift between development environments, indentation and line breaks can sometimes be affected, causing major headaches! Let’s say we run the following code: def calculate_sum(a,b): result = a + b return result def calculate_product(a,b):result = a * b return result def main(): a=5 b=6 sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) product_result = calculate_product(a,b) print(&quot;Product:&quot;, product_result) if __name__ == &#39;__main__&#39;: main() ## unexpected indent (&lt;string&gt;, line 3) We get the error above because our indentation is off. Let’s ask ChatGPT to clean things up. “Can you assist me with correcting the formatting and indentation issues in my Python code?” Of course! Here is the code after correcting the formatting and indentation: def calculate_sum(a, b): result = a + b return result def calculate_product(a, b): result = a * b return result def main(): a = 5 b = 6 sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) product_result = calculate_product(a, b) print(&quot;Product:&quot;, product_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 ## Product: 30 Much better! This can be quite handy when you can’t immediately see what is wrong with the formatting or if you are working with a large codebase. 3.3 Example Two: Styling and Convention Sometimes programming languages have more flexible rules where there are multiple ways to take the same or almost the same action. For example, in the R programming language, there are several ways to perform variable assignment. However, is is generally accepted among R programmers that the &lt;- operator should be used. Single and double quotes can be used for character types interchangeably, but it’s generally a good idea to stick with one or the other. 3.3.1 Commonly Accepted Convention Let’s say we have the following code: a &lt;- &quot;apple&quot; b = &#39;banana&#39; &quot;carrot&quot; -&gt; c c(a, b, c) ## [1] &quot;apple&quot; &quot;banana&quot; &quot;carrot&quot; This code does not produce any errors, but it doesn’t follow typical R convention. Let’s ask ChatGPT to clean things up. “Can you help me reformat my R code to follow accepted style conventions?” Sure, here’s the cleaned-up R code: a &lt;- &quot;apple&quot; b &lt;- &quot;banana&quot; c &lt;- &quot;carrot&quot; Much better! This code will now look more familiar to other R programmers. 3.3.2 Visual Styling Some languages are flexible about line breaks, indentation, and spacing among code blocks. If you’re rapidly developing, things can get messy pretty quickly. Many development environments, for example RStudio and PyCharm, have the ability to format your code for you without changing any of the code itself. However, you can also get AI to do this according to your own preferences. d &lt;- c(rep(a,5),rep(b,5),rep(c,5),paste(a,b,c),paste(c,b,a)) This code is pretty hard to read. Let’s see if AI can do better. “Can you space out this R code to make it more readable?” Sure! Here’s the same code with added spacing for improved readability: d &lt;- c(rep(a, 5), rep(b, 5), rep(c, 5), paste(a, b, c), paste(c, b, a)) Better! It’s easier to interpret because only one action is being taken on each step. By spacing out the code and breaking it into multiple lines, it becomes easier for the human eye to scan for structure, logic, errors, and/or inconsistencies. 3.4 Example Three: Staying DRY The DRY (Don’t Repeat Yourself) programming tenet is essential to good software. By avoiding repetition in code, we can reduce the amount of duplicate code we need to write and maintain. If we need to change the functionality of a certain piece of code, we have to make the same change in multiple places, which can be time-consuming and error-prone. Let’s take the following Python code: def print_greetings(): print(&quot;Hello, Alice!&quot;) print(&quot;Hello, Bob!&quot;) print(&quot;Hello, Carol!&quot;) print(&quot;Hello, David!&quot;) print(&quot;Hello, Eve!&quot;) print_greetings() ## Hello, Alice! ## Hello, Bob! ## Hello, Carol! ## Hello, David! ## Hello, Eve! Notice how repetitive this code is? print() and the string \"Hello, \" appear five times. We can improve this! “Could you please refactor my Python code to make it more DRY?” Sure, here’s a refactored version of your code: def print_greeting(name): print(f&quot;Hello, {name}!&quot;) def print_greetings(): names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;David&quot;, &quot;Eve&quot;] for name in names: print_greeting(name) print_greetings() ## Hello, Alice! ## Hello, Bob! ## Hello, Carol! ## Hello, David! ## Hello, Eve! Now let’s imagine your software lead has asked us to change the greeting to Spanish. Notice how we only have to change the second line of code: def print_greeting(name): print(f&quot;¡Hola, {name}!&quot;) def print_greetings(): names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;David&quot;, &quot;Eve&quot;] for name in names: print_greeting(name) print_greetings() ## ¡Hola, Alice! ## ¡Hola, Bob! ## ¡Hola, Carol! ## ¡Hola, David! ## ¡Hola, Eve! Much easier. 3.5 Example Four: Keeping Code Alive During software development, code is often changing rapidly. It’s common to end up with functions or variables you don’t need anymore. It’s best practice to remove “dead” code from your codebase: it’s distracting and can make maintenance more challenging. Programmers should resist the urge to hang on to unused code in the expectation that they might need it one day. Version control, such as provided by git and GitHub, let you keep a record of old code without cluttering your final version. Let’s take a look at some Python code with some dead code: def default_values(): a = 5 b = 6 return a, b def calculate_sum(a, b): result = a + b return result def calculate_product(x, y): return x * y def simulate_data(): a, b = default_values() dat = calculate_sum(a, b) + calculate_sum(a, b) return dat def main(): a = 5 b = 6 a, b = default_values() sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 Some of these functions aren’t used in the final step, typically defined in python as the main() function. Let’s ask AI to remove them. “I need help with eliminating unused functions in my Python script.” Sure! Here’s a refactored version: def default_values(): a = 5 b = 6 return a, b def calculate_sum(a, b): result = a + b return result def main(): a = 5 b = 6 a, b = default_values() sum_result = calculate_sum(a, b) print(&quot;Sum:&quot;, sum_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 Great! Now our code is much more manageable. This code only includes the necessary functions needed to run the main() function. We can go a step further! “Can you help me refactor my python code to make it more concise?” Certainly! Here’s a more concise version of your code: def calculate_sum(a=5, b=6): return a + b def main(): sum_result = calculate_sum() print(&quot;Sum:&quot;, sum_result) if __name__ == &#39;__main__&#39;: main() ## Sum: 11 In this version, the calculate_sum function is simplified to take default arguments for a and b. This means the default_values function is no longer necessary. The a and b variables are also removed from main, as they are no longer needed. Much better and easier to look at overall. 3.6 Example Five: Making Code Readable Usually, our first goal as programmers is to get the response we need from the code. Readability might be the last thing on our minds. Luckily, AI can help with this. Let’s imagine we whipped up this code pretty quickly. It is tough to read, and it could definitely be improved. for(term in c(&quot;good&quot;,&quot;bad&quot;,&quot;ugly&quot;)){ print(c(rep(term,3),paste(&quot;really&quot;,stringr::str_to_upper(term)))) } ## [1] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;really GOOD&quot; ## [1] &quot;bad&quot; &quot;bad&quot; &quot;bad&quot; &quot;really BAD&quot; ## [1] &quot;ugly&quot; &quot;ugly&quot; &quot;ugly&quot; &quot;really UGLY&quot; Let’s see if AI can do better. “Can you help me clean up this R code so it is more readable?” Sure! Here’s a more readable version of the code: library(stringr) for(term in c(&quot;good&quot;, &quot;bad&quot;, &quot;ugly&quot;)) { print(c(rep(term, 3), paste(&quot;really&quot;, str_to_upper(term)))) } ## [1] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;really GOOD&quot; ## [1] &quot;bad&quot; &quot;bad&quot; &quot;bad&quot; &quot;really BAD&quot; ## [1] &quot;ugly&quot; &quot;ugly&quot; &quot;ugly&quot; &quot;really UGLY&quot; I added whitespace around operators and after commas for better readability. I also loaded the stringr package explicitly using library() to make the code more self-contained. This is a good start, but not much has changed. Let’s try again. On ChatGPT, we can click “Regenerate Response”. Here’s a cleaned-up version of the R code that is more readable: library(stringr) terms &lt;- c(&quot;good&quot;, &quot;bad&quot;, &quot;ugly&quot;) for (term in terms) { rep_term &lt;- rep(term, 3) upper_term &lt;- str_to_upper(term) really_upper_term &lt;- paste(&quot;really&quot;, upper_term) result &lt;- c(rep_term, really_upper_term) print(result) } ## [1] &quot;good&quot; &quot;good&quot; &quot;good&quot; &quot;really GOOD&quot; ## [1] &quot;bad&quot; &quot;bad&quot; &quot;bad&quot; &quot;really BAD&quot; ## [1] &quot;ugly&quot; &quot;ugly&quot; &quot;ugly&quot; &quot;really UGLY&quot; I’ve stored the repeated term and the uppercased term in separate variables to make the code more readable. I’ve also separated the construction of the “really” phrase from the uppercased term to make it clearer what’s happening. Finally, I’ve used whitespace and indentation to make the structure of the code more apparent. Better! While the code takes up a greater number of lines, it’s easier to interpret because only one action is being taken on each step. 3.7 Example Six: Keep it Brief As we learned above, following the DRY principle and removing dead code can make your code easier to interpret, maintain, and debug. However, sometimes the issue is the functions themselves. No one has perfect knowledge of everything in their programming language. AI can help us determine if there are any more efficient sets of functions that do the same thing. Here is some code that plays with the “CO2” dataset in R: library(datasets) for (type in unique(CO2$Type)) { dat_subset &lt;- CO2[CO2$Type == type, ] for (plant in unique(dat_subset$Plant)) { dat_subset_2 &lt;- dat_subset[dat_subset$Plant == plant, ] print(paste(dat_subset_2$Plant[1], round(mean(dat_subset_2$uptake), 1))) } } ## [1] &quot;Qn1 33.2&quot; ## [1] &quot;Qn2 35.2&quot; ## [1] &quot;Qn3 37.6&quot; ## [1] &quot;Qc1 30&quot; ## [1] &quot;Qc2 32.7&quot; ## [1] &quot;Qc3 32.6&quot; ## [1] &quot;Mn1 26.4&quot; ## [1] &quot;Mn2 27.3&quot; ## [1] &quot;Mn3 24.1&quot; ## [1] &quot;Mc1 18&quot; ## [1] &quot;Mc2 12.1&quot; ## [1] &quot;Mc3 17.3&quot; Let’s see if AI has any ideas for making it more concise. “Can you make this code more concise?” Here’s a more concise version using dplyr package in R: library(dplyr) CO2 %&gt;% group_by(Type, Plant) %&gt;% summarize(mean_uptake = mean(uptake)) ## # A tibble: 12 × 3 ## # Groups: Type [2] ## Type Plant mean_uptake ## &lt;fct&gt; &lt;ord&gt; &lt;dbl&gt; ## 1 Quebec Qn1 33.2 ## 2 Quebec Qn2 35.2 ## 3 Quebec Qn3 37.6 ## 4 Quebec Qc1 30.0 ## 5 Quebec Qc3 32.6 ## 6 Quebec Qc2 32.7 ## 7 Mississippi Mn3 24.1 ## 8 Mississippi Mn2 27.3 ## 9 Mississippi Mn1 26.4 ## 10 Mississippi Mc2 12.1 ## 11 Mississippi Mc3 17.3 ## 12 Mississippi Mc1 18 This code groups the CO2 dataset by Type and Plant, calculates the mean uptake for each group using summarize, and then prints the resulting data frame. The code is shorter and more concise because it uses the dplyr package, which has built-in functions for data manipulation and summarization. Refactoring the code to be more concise using dplyr makes it easier to read and understand the steps involved in the data manipulation. It also reduces the number of nested loops and intermediate variables, making the code more efficient and reducing the chance of errors. Ultimately, it is your job as a programmer to use your best judgment on the fine balance between brevity and readability, as the best solution is not always this obvious. Remember that you can regenerate the AI’s response if you want more options. 3.8 Code optimization loops! 3.9 Case studies / examples in industry (if any) 3.10 Common mistakes / edge cases / things to watch out for 3.11 Challenges / limitations 3.12 Hands-On Exercise Now it’s your turn to try. Let’s say you … Note: This code is just an example and was written strictly for educational purposes. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-14 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## curl 4.3 2019-12-02 [1] RSPM (R 4.0.3) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## dplyr * 1.0.2 2020-08-18 [1] RSPM (R 4.0.2) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## generics 0.0.2 2018-11-29 [1] RSPM (R 4.0.0) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## here 1.0.1 2020-12-13 [1] CRAN (R 4.0.2) ## highr 0.8 2019-03-20 [1] RSPM (R 4.0.3) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## httr 1.4.2 2020-07-20 [1] RSPM (R 4.0.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.2) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## png 0.1-8 2022-11-29 [1] CRAN (R 4.0.2) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## purrr 0.3.4 2020-04-17 [1] RSPM (R 4.0.5) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## Rcpp 1.0.10 2023-01-22 [1] CRAN (R 4.0.2) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## reticulate * 1.28 2023-01-27 [1] CRAN (R 4.0.2) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr * 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## tidyselect 1.1.0 2020-05-11 [1] RSPM (R 4.0.3) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["understanding-unfamiliar-code.html", "Chapter 4 Understanding Unfamiliar Code 4.1 Using AI to understand code 4.2 Example One: Summarizing Code You Didn’t Write 4.3 Example Two: Identifying a Coding Language 4.4 Example Three: Interpreting Regex 4.5 Example Four: Understanding Variables and Functions 4.6 Edge Cases 4.7 Limitations? 4.8 Hands-On Exercise", " Chapter 4 Understanding Unfamiliar Code As a programmer, you will frequently encounter situations where you need to read and understand code written by other developers. This could be because you are collaborating on a project, you have taken over maintenance of an existing codebase, or you are learning new syntax or skills that require reading example codes. Comprehending code written by someone else is a distinct skill from being able to write your own code, and it takes practice to become proficient at it. Reading unfamiliar code is like exploring an unfamiliar city without a map or a guide. Just like in a new city, you may not know where to start or how to navigate the codebase. You may encounter unfamiliar syntax, functions, and libraries that you have never seen before, just as you might encounter new streets, buildings, and landmarks. At first, you may feel disoriented and overwhelmed, and may need to spend some time getting oriented and familiarizing yourself with the environment. As you explore, you may start to see patterns and similarities, just as you might begin to recognize neighborhoods and landmarks in a new city. You may also encounter dead-ends, confusing intersections, and unexpected detours, just as you might encounter bugs and errors in the code. To make progress in this unfamiliar territory, you may need to rely on a combination of intuition, deduction, and experimentation. You may need to break down the code into smaller pieces, analyze the behavior of each piece, and gradually build up a mental model of how the code works. You may also need to consult documentation, online resources, or other experts who are familiar with the codebase, just as you might ask locals or consult a map in a new city. In the end, with patience, persistence, and a willingness to learn, you can successfully navigate the unfamiliar code and achieve your goals, just as you can successfully explore a new city and discover its hidden treasures. Learning how to read and understand code written by someone else is a valuable skill that can help you be a more effective programmer. By being able to read and comprehend unfamiliar code, you can contribute to projects more quickly, diagnose and fix bugs more effectively, and learn new programming techniques and best practices. As with any skill, the more you practice reading and understanding code written by others, the more comfortable and proficient you will become at it. 4.1 Using AI to understand code While anyone can learn to understand code written by someone else, using AI language models to achieve this has three significant advantages. Firstly, AI tools can analyze the codebase and provide insights into its structure, complexity, and potential defects. This analysis can identify parts of the code that may be challenging to understand, maintain or improve. Based on the analysis, the AI tools may also make recommendations on how to enhance the codebase for better functionality and readability. Secondly, AI tools can assist in summarizing large codebases, which can be challenging to comprehend in detail. Such codebases may have multiple files, functions, and classes, which could take a considerable amount of time to read and understand thoroughly. With the help of AI, programmers can get a high-level overview of the codebase without going through it line by line. This approach can save substantial time and effort, especially when dealing with complex codebases. By gaining a deeper understanding of the codebase, developers can make better-informed decisions when it comes to adding new features, improving existing functionality, or fixing bugs. AI language models can also quickly analyze large amounts of code and provide a summary of its functionality, which can save developers a significant amount of time compared to manually analyzing the code line-by-line. By automating this process, developers can devote more time to other important tasks, such as debugging, testing, and improving the code. Finally, AI can help programmers to understand the comments and documentation written by other developers, as well as their design decisions and implementation details of code. These insights can help programmers to understand the code’s purpose and the assumptions and limitations of the codebase. As a programmer, at some point you will almost certainly need to deal with “legacy code,” or code written by someone else years (or decades) earlier. Often when you run across this code, the original programmer is not available to answer questions. Even if they are, they likely won’t remember all the details you need about the decisions they made while creating the program. AI bots are an extremely powerful tool that can fill in the gaps of understanding, especially when the code isn’t annotated well or at all. This can be especially helpful when working with older or legacy code, or when collaborating with other developers on a project. For instance, understanding how a particular piece of code works and why it was implemented a certain way can help developers identify potential issues and find more effective solutions. Ethical Considerations AI language models like ChatGPT, Bard, and others have the ability to summarize code and offer valuable insights into its workings. However, it’s important to consider the ethics of using AI to summarize code that someone else has written. Several factors come into play, such as the intended purpose of the summary, the ownership of the code, and the potential impact of the summary. Specifically, it’s important to take into account who owns the code, the reason for summarizing the code, and whether the code contains any sensitive or personal information. If the reason for summarizing the code is for educational or research purposes, and the code is either publicly available or the owner has granted explicit permission for its use, then it’s likely ethical to use AI to summarize the code. However, if the summary is intended for commercial purposes or could potentially infringe upon the owner’s intellectual property rights, it may be unethical to use AI to summarize the code without obtaining the owner’s consent. Additionally, if the code contains confidential or personal information, using AI to summarize it could raise privacy concerns. In such cases, obtaining explicit consent from the owner and implementing appropriate measures to ensure that the summary does not reveal any confidential information may be necessary. Overall, the ethics of using AI to summarize code someone else wrote depend on the specific circumstances and should be carefully considered before proceeding. It is important to respect the intellectual property rights and privacy of the owner and ensure that the summary is used in a responsible and ethical manner. 4.2 Example One: Summarizing Code You Didn’t Write Here’s some simple code using the R programming language, written by an unnamed programmer. If you are familiar with R, you might be able to understand what this code does with little effort. However, if you don’t know R, you’re relatively new to R, or you’re just having a bad day, understanding what this bit of code can take a great deal more energy and time. AI language bots can ease that burden. library(tidyverse) d &lt;- ggplot2::diamonds d_sel &lt;- d %&gt;% select(carat, cut, color, clarity, depth, table, price) d_fil &lt;- d_s %&gt;% filter(price &gt; 5000) d_bin &lt;- d_fil %&gt;% mutate(carat_bins = cut_width(carat, width = 0.2)) d_summ &lt;- d_bin %&gt;% group_by(carat_bins, cut, color, clarity) %&gt;% summarize(mean_price = mean(price), sd_price = sd(price)) ggplot(d_sum, aes(x = mean_price, y = sd_price)) + geom_point() + facet_grid(cut ~ color + clarity) + labs(x = &quot;Mean Price&quot;, y = &quot;Standard Deviation of Price&quot;) We first ask Claude-instant (as implemented by Poe) to explain the purpose of this code. “What does this code do?” You can always ask for clarification if you need more information. “Can you explain what each step does in detail?” You can also ask about both the tidyverse package and the dataset being used. “What is do the tidyverse packages do?” “Can you tell me more about the diamonds dataset?” 4.3 Example Two: Identifying a Coding Language Sometimes you might have to work with legacy code. Legacy code can be difficult to work with, especially if it is written in a language or style that you are not familiar with. There are more than 700 programming languages in use today, so it is impossible for any programmer to know them all. AI can be a helpful tool for identifying the language and version of legacy code, which can make your life just a little easier. Let’s look at example code that might have been written decades ago. program temperature_smog_analysis; uses Math; const n_temperatures = 1000; n_smog_measures = 500; type TemperatureArray = array[0..n_temperatures-1] of integer; SmogArray = array[0..n_smog_measures-1] of integer; var temperatures: TemperatureArray; smog_measures: SmogArray; combined_data: array of integer; slope, y_intercept: double; i, j: integer; function connect_to_database(filename: string): integer; begin { implementation of connect_to_database function } end; function retrieve_temperatures(fd: integer): integer; begin { implementation of retrieve_temperatures function } end; function retrieve_smog_measures(fd: integer): integer; begin { implementation of retrieve_smog_measures function } end; function retrieve_temperature(fd, index: integer): integer; begin { implementation of retrieve_temperature function } end; function retrieve_smog_measure(fd, index: integer): integer; begin { implementation of retrieve_smog_measure function } end; procedure close_database(fd: integer); begin { implementation of close_database function } end; begin SetLength(combined_data, n_temperatures + n_smog_measures); fd := connect_to_database(&#39;seattle_temperature.db&#39;); n_temperatures := retrieve_temperatures(fd); sfd := connect_to_database(&#39;seattle_smog.db&#39;); n_smog_measures := retrieve_smog_measures(sfd); for i := 0 to n_temperatures-1 do begin temperatures[i] := retrieve_temperature(fd, i); combined_data[i] := temperatures[i]; end; for j := 0 to n_smog_measures-1 do begin smog_measures[j] := retrieve_smog_measure(sfd, j); combined_data[j + n_temperatures] := smog_measures[j]; end; close_database(fd); close_database(sfd); slope := 0.0; y_intercept := 0.0; for i := 0 to n_temperatures+n_smog_measures-1 do begin slope := slope + (combined_data[i + n_temperatures] - y_intercept) * (combined_data[i] - y_intercept); y_intercept := y_intercept + (combined_data[i + n_temperatures] - y_intercept); end; slope := slope / (n_temperatures + n_smog_measures); y_intercept := y_intercept / (n_temperatures + n_smog_measures); writeln(&#39;The slope is &#39;, slope:0:2, &#39; and the y-intercept is &#39;, y_intercept:0:2, &#39;.&#39;); readln; end. We can ask Bard to take a guess at what the coding language might be. “What language is this code written in?” We can explore further to figure out what indicators tell Bard the language is Pascal. “How do you know this is Pascal?” It turns out there are multiple versions of Pascal. Since you will presumably need to work with this legacy code, you might want to know which version it is. “What version of Pascal is this?” 4.4 Example Three: Interpreting Regex Regex (short for Regular Expressions) is a powerful tool used to describe patterns in text. It’s a sequence of characters that define a search pattern. Regular expressions can be a powerful tool for data cleaning, text mining, and data validation. They are widely used in web development, data science, and other fields where text processing is important. They can also be tricky to understand at first because they involve a specific syntax that can be complex. We can use ChatGPT to explain regex in a bit of someone else’s code. x = sub(&quot;.*presentation/&quot;,&quot;&quot;,x) “What does this do?” x = sub(&quot;/d/e&quot;,&quot;/d&quot;,x) “What about this?” 4.5 Example Four: Understanding Variables and Functions 4.6 Edge Cases 4.7 Limitations? 4.8 Hands-On Exercise Now it’s your turn to try. Let’s say you were handed this bit of code to work with (and eventually modify), but first you need to figure out what’s going on with it. Unfortunately, the original programmer left very little in the way of notes or annotation. Note: This code is just an example and was written strictly for educational purposes. use ode_solvers::{Euler, OdeMethod}; use plotters::prelude::*; use std::fs::File; const N: f64 = 1000000.0; const I0: f64 = 10.0; const R0: f64 = 0.0; const S0: f64 = N - I0 - R0; const BETA: f64 = 0.3; const GAMMA: f64 = 0.1; fn sir_model(t: f64, y: &amp;[f64], v: f64) -&gt; Vec&lt;f64&gt; { let s = y[0]; let i = y[1]; let r = y[2]; let dsdt = -BETA * s * i / N - v * s; let didt = BETA * s * i / N - GAMMA * i; let drdt = GAMMA * i + v * s; vec![dsdt, didt, drdt] } fn main() { let mut solver = Euler::new(sir_model); solver.set_initial_condition(&amp;[S0, I0, R0]); let root = BitMapBackend::new(&quot;sir_vaccination.png&quot;, (800, 600)).into_drawing_area(); root.fill(&amp;WHITE).unwrap(); let mut chart = ChartBuilder::on(&amp;root) .caption(&quot;SIR model with vaccination&quot;, (&quot;sans-serif&quot;, 40)) .set_label_area_size(LabelAreaPosition::Left, 60) .set_label_area_size(LabelAreaPosition::Bottom, 40) .build_cartesian_2d(0.0..100.0, 0.0..N) .unwrap(); let mut data1 = vec![]; for _ in 0..1000 { let y = solver.integrate(0.1, 0.0); data1.push((solver.time(), y[0], y[1], y[2])); } let vac_rate = 0.1; let vac_coverage = 0.5; let vac_num = vac_coverage * N; let mut data2 = vec![]; for i in 0..1000 { let t = i as f64 * 0.1; let v = if t &gt;= 50.0 &amp;&amp; t &lt; 150.0 {vac_num * vac_rate} else {0.0}; let y = solver.integrate(0.1, v); data2.push((solver.time(), y[0], y[1], y[2])); } chart .configure_mesh() .x_labels(10) .y_labels(10) .disable_x_mesh() .disable_y_mesh() .draw() .unwrap(); chart .draw_series(LineSeries::new( data1.iter().map(|d| QUESTIONS: What language is the code written in? What are two clues that tell you the language? What is the overall task this code does? What is a new feature you could add to the code? How could you add that feature? What does this bit of code do? let root = BitMapBackend::new(&quot;sir_vaccination.png&quot;, (800, 600)).into_drawing_area(); Why would a programmer set up a section of code like this? fn sir_model(t: f64, y: &amp;[f64], v: f64) -&gt; Vec&lt;f64&gt; { let s = y[0]; let i = y[1]; let r = y[2]; let dsdt = -BETA * s * i / N - v * s; let didt = BETA * s * i / N - GAMMA * i; let drdt = GAMMA * i + v * s; vec![dsdt, didt, drdt] } How are these variables initialized? let s = y[0]; let i = y[1]; let r = y[2]; What are some other variables that could be added to this command to customize the output? chart .configure_mesh() .x_labels(10) .y_labels(10) .disable_x_mesh() .disable_y_mesh() .draw() .unwrap(); devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-04-14 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## curl 4.3 2019-12-02 [1] RSPM (R 4.0.3) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## highr 0.8 2019-03-20 [1] RSPM (R 4.0.3) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## httr 1.4.2 2020-07-20 [1] RSPM (R 4.0.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["appendix.html", "Appendix Additional Programming Languages", " Appendix Additional Programming Languages You might also encounter these programming languages on your software journey. Julia Julia is designed for numerical and scientific computing, data analysis, and machine learning. It has a syntax that is easy to learn and read, making it an ideal choice for data scientists, engineers, and researchers. Julia code can also be compiled to native machine code using the Julia compiler. Because Julia is a relatively new language, it has fewer add-on libraries and resources available compared to more established languages. MATLAB MATLAB is a high-level programming language and development environment commonly used for numerical computation, data analysis, and visualization. It is widely used in engineering, physics, and finance, among other fields. It is generally considered to have a user-friendly syntax and is relatively easy to learn compared to other languages. MATLAB has a development environment called MATLAB Compiler that allows you to package MATLAB code into standalone executables or shared libraries for use on a wide variety of operating systems. Fortran Fortran has been around for decades and has a long history in scientific and engineering communities. It has a more challenging syntax and is considered harder to learn than some of the other languages on this list. It is primarily used for scientific and engineering applications that require numerical computations and simulations such as computational physics, weather forecasting, and computational chemistry. Rust Rust is a systems programming language that focuses on speed, reliability, and memory safety. It is commonly used for developing performance-critical software, such as operating systems, web browsers, and game engines. Rust’s syntax is similar to C++, but is often considered to have a steeper learning curve due to its focus on memory safety and ownership concepts. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
